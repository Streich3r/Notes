<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meine Offline-Notizen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root{
            /* BASICS */
            --btn-gray: #4b5563; /* bg-gray-600 */
            --btn-blue: #2563eb; /* bg-blue-600 */
            --btn-green: #10b981; /* bg-green-600 */
            --btn-yellow: #fbbf24; /* bg-yellow-600 */
            --accent: #6aa1ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            -webkit-tap-highlight-color: transparent;
        }

        .note-card {
            background-color: #1a202c;
            border-color: #2d3748;
            cursor: grab;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .note-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        #note-editor {
            min-height: 100px;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid #4a5568; 
            background-color: #1a202c;
            color: #ffffff;
            outline: none; 
            transition: all 0.3s;
        }
        
        #note-editor:focus {
            outline: none !important;
        }

        /* ----------------------------------------------------- */
        /* --- RECHNER-PRINZIP CSS-REGELN FÜR ALLE BUTTONS --- */
        /* ----------------------------------------------------- */
        .calculator-btn, label[for="import-file-input"] {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: transform .06s ease, background-color 0.2s ease;
            border: none;
        }

        .calculator-btn:active, label[for="import-file-input"]:active {
            transform: scale(0.96);
        }

        .calculator-btn:focus, label[for="import-file-input"]:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        .calculator-btn:focus-visible, label[for="import-file-input"]:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        /* Graue Buttons (Toolbar, Sort, Modal-Cancel) */
        .toolbar-btn, .dropdown-item, #sort-dropdown-btn, #modal-cancel-btn, #link-cancel-btn, .note-action-btn {
            background-color: var(--btn-gray) !important;
        }
        
        .toolbar-btn:hover:not(.active), .dropdown-item:hover:not(.active), #sort-dropdown-btn:hover, #modal-cancel-btn:hover, #link-cancel-btn:hover, .note-action-btn:hover {
            background-color: var(--btn-gray) !important;
        }
        
        .toolbar-btn:active, .dropdown-item:active, #sort-dropdown-btn:active, #modal-cancel-btn:active, #link-cancel-btn:active, .note-action-btn:active {
             background-color: #374151 !important; /* bg-gray-700 */
        }

        /* WICHTIG: Blauer Hintergrund für aktive Toolbar-Buttons und Dropdown-Elemente */
        .toolbar-btn.active, .dropdown-item.active {
            background-color: var(--btn-blue) !important;
            color: #ffffff !important;
        }

        /* Blaue Buttons (Save, Modal-Confirm, Link-Insert) */
        #save-note-btn, #modal-confirm-btn, #link-insert-btn {
            background-color: var(--btn-blue) !important;
        }
        #save-note-btn:hover, #modal-confirm-btn:hover, #link-insert-btn:hover {
            background-color: #1d4ed8 !important; /* bg-blue-700 */
        }
        #save-note-btn:active, #modal-confirm-btn:active, #link-insert-btn:active {
            background-color: #1e40af !important; /* bg-blue-800 */
        }

        /* Grüne Buttons (Export) */
        #export-btn {
            background-color: var(--btn-green) !important;
        }
        #export-btn:hover {
            background-color: #059669 !important; /* bg-green-700 */
        }
        #export-btn:active {
            background-color: #047857 !important; /* bg-green-800 */
        }
        
        /* Gelbe Buttons (Import) */
        label[for="import-file-input"] {
            background-color: var(--btn-yellow) !important;
        }
        label[for="import-file-input"]:hover {
             background-color: #f59e0b !important; /* bg-yellow-600/700 */
        }
        label[for="import-file-input"]:active {
            background-color: #a16207 !important; /* bg-yellow-800 */
        }
        
        /* Dropdown Menü Styling */
        .dropdown-menu {
            position: absolute;
            z-index: 10;
            top: 100%;
            left: 0;
            margin-top: 0.5rem;
            background-color: #374151; /* bg-gray-700 */
            border-radius: 0.5rem;
            padding: 0.25rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            width: max-content;
            min-width: 100%;
        }

        .dropdown-menu.active {
            display: flex;
        }

        #note-editor:empty:before {
            content: attr(placeholder);
            color: #718096;
            pointer-events: none;
            display: block;
        }
        
        /* Spezielle Regel für Link-Färbung im Editor */
        #note-editor a {
            color: #3b82f6; /* Tailwind blue-500 */
            text-decoration: underline;
        }
        
        /* --- STABILISIERTE LISTE-STYLES --- */
        #note-editor ul, #note-editor ol, .note-card ul, .note-card ol {
            margin: 0;
            padding-left: 1.5rem; 
        }
        
        #note-editor li, .note-card li {
            color: #ffffff !important;
        }

        #note-editor li::marker, .note-card li::marker {
            color: #ffffff !important;
        }
        
        /* ERGÄNZUNG: Spezielle CSS-Regeln für die Listentypen (aus besser2.txt) */
        /* Kreise (Hohle Kreise) */
        #note-editor ul[style*="list-style-type: circle"], .note-card ul[style*="list-style-type: circle"] {
            list-style-type: circle !important;
        }
        
        /* Punkte (Gefüllte Scheiben/Discs) */
        #note-editor ul[style*="list-style-type: disc"], .note-card ul[style*="list-style-type: disc"] {
            list-style-type: disc !important;
        }
        
        /* Fallback für ul ohne Stil */
        #note-editor ul:not([style]), .note-card ul:not([style]) {
             list-style-type: disc !important;
        }
        
        #note-editor ol, .note-card ol {
            list-style-type: decimal;
        }
        
        /* Stil für die neuen Icon-Buttons */
        .note-action-btn {
            width: 38px;
            height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Entfernt internes Padding, da wir feste Größe haben */
            font-size: 1.25rem; /* Für die Icons */
            border-radius: 9999px; /* Rund */
        }
    </style>
</head>
<body class="bg-black min-h-screen p-4 flex items-center justify-center">

    <div class="bg-gray-900 p-6 rounded-3xl shadow-2xl w-full max-w-4xl transition-all duration-300 transform scale-100">
        
        <header class="mb-6 border-b pb-4 border-gray-700">
            <h1 class="text-4xl font-extrabold text-gray-100 text-center">
                Meine Offline-Notizen
            </h1>
        </header>

        <div class="mb-6 p-4 bg-gray-800 rounded-2xl shadow-inner">
            <h2 class="text-2xl font-bold text-gray-200 mb-4">Neue Notiz erstellen</h2>
            
            <input type="text" id="note-title-input" placeholder="Titel der Notiz (optional)" class="w-full p-3 mb-4 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
  
            <div class="flex flex-wrap gap-2 mb-4 p-2 bg-gray-700 rounded-xl">
                <button id="bold-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 font-bold">B</button>
                <button id="italic-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 italic">I</button>
                <button id="underline-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 underline">U</button>
                
                <div class="relative inline-block">
                    <button id="list-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Aufzählung
                    </button>
                    <div id="list-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="decimal">Nummerierung</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="disc">Punkte</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="circle">Kreise</button>
                    </div>
                </div>

                <div class="relative inline-block">
                    <button id="size-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Schriftgröße
                    </button>
                    <div id="size-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="1">Klein</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="3">Mittel</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="5">Groß</button>
                    </div>
                </div>

                <div class="relative inline-block">
                    <button id="color-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Schriftfarbe
                    </button>
                    <div id="color-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-white" data-value="white">Weiß</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-red-500" data-value="red">Rot</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-green-500" data-value="green">Grün</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-blue-500" data-value="blue">Blau</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-yellow-500" data-value="yellow">Gelb</button>
                    </div>
                </div>

                <button id="link-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Link
                </button>

                <button id="indent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Einrücken
                </button>
                <button id="outdent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Ausrücken
                </button>
            </div>
        
            <div id="note-editor" class="w-full rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none transition-all duration-300" contenteditable="true" placeholder="Schreiben Sie hier Ihre neue Notiz..."></div>
  
            <div class="mt-4 flex justify-end space-x-2">
                <button id="save-note-btn" class="calculator-btn text-white font-medium py-2 px-5 rounded-full shadow-lg transform">
                    Notiz speichern
                </button>
            </div>
    
        </div>

        <div class="mb-6 flex flex-col md:flex-row gap-4">
            <input type="text" id="search-input" placeholder="Notizen durchsuchen..." class="w-full md:w-1/3 p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            
            <div class="flex flex-col sm:flex-row gap-4 w-full md:w-2/3">
                
                <div class="relative w-full sm:w-1/2">
                    <button 
                        id="sort-dropdown-btn" 
                        class="calculator-btn w-full p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 text-left">
                        Sortieren nach: Unsortiert
                    </button>
                    <div id="sort-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg active" data-value="unsorted">Unsortiert</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="newest">Datum (neueste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="oldest">Datum (älteste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-asc">Titel (A-Z)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-desc">Titel (Z-A)</button>
                    </div>
                </div>

                <div class="flex gap-2 w-full sm:w-1/2">
                    <button id="export-btn" class="calculator-btn w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium">
                        Export 💾
                    </button>
                    <label for="import-file-input" 
                        class="w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium cursor-pointer text-center flex items-center justify-center">
                        Import 📥
                    </label>
                    <input type="file" id="import-file-input" accept="application/json" style="display: none;">
                </div>
            </div>
        </div>

        <div id="notes-list" class="space-y-4">
        </div>

        <div id="loading-indicator" class="text-center text-gray-400 mt-8 hidden">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
            <p class="mt-2">Notizen werden geladen...</p>
        </div>

        <div id="no-notes-message" class="text-center text-gray-400 mt-8 hidden">
            <p>Sie haben noch keine Notizen. Fügen Sie eine neue hinzu, um zu beginnen!</p>
        </div>
    </div>

    <div id="modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-sm w-full">
            <p id="modal-text" class="text-lg font-semibold text-gray-200 text-center mb-4"></p>
            <div class="flex justify-center space-x-4">
                <button id="modal-confirm-btn" class="calculator-btn text-white font-medium py-2 px-5 rounded-full">
                    OK
                </button>
                <button id="modal-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full hidden">
                    Abbrechen
                </button>
            </div>
        </div>
    </div>

    <div id="link-modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-lg w-full">
            <h3 class="text-xl font-bold text-gray-200 mb-4 text-center">Link einfügen</h3>
            <p class="text-gray-300 mb-4 text-center">Geben Sie die URL für den Link ein.</p>
            <input type="text" id="link-url-input" placeholder="https://beispiel.de" class="w-full p-3 rounded-xl border border-gray-600 bg-gray-900 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            <div class="mt-6 flex justify-end space-x-4">
                <button id="link-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full">
                    Abbrechen
                </button>
                <button id="link-insert-btn" class="calculator-btn text-white font-medium py-2 px-5 rounded-full">
                    Einfügen
                </button>
            </div>
        </div>
    </div>

    <script>
        // DOM-Elemente
        const notesList = document.getElementById('notes-list');
        const noteTitleInput = document.getElementById('note-title-input');
        const noteEditor = document.getElementById('note-editor');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const searchInput = document.getElementById('search-input');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noNotesMessage = document.getElementById('no-notes-message');

        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const indentBtn = document.getElementById('indent-btn');
        const outdentBtn = document.getElementById('outdent-btn');
        const linkBtn = document.getElementById('link-btn');
        
        const listDropdownMenu = document.getElementById('list-dropdown-menu');
        const listDropdownBtn = document.getElementById('list-dropdown-btn');
        const listDropdownItems = listDropdownMenu.querySelectorAll('.dropdown-item');
        
        const sizeDropdownMenu = document.getElementById('size-dropdown-menu');
        const sizeDropdownBtn = document.getElementById('size-dropdown-btn');
        const sizeDropdownItems = sizeDropdownMenu.querySelectorAll('.dropdown-item');
        
        const colorDropdownMenu = document.getElementById('color-dropdown-menu');
        const colorDropdownBtn = document.getElementById('color-dropdown-btn');
        const colorDropdownItems = colorDropdownMenu.querySelectorAll('.dropdown-item');

        // Sortier-Elemente
        const sortDropdownBtn = document.getElementById('sort-dropdown-btn');
        const sortDropdownMenu = document.getElementById('sort-dropdown-menu');
        const sortDropdownItems = sortDropdownMenu.querySelectorAll('.dropdown-item');

        // KONSTANTEN FÜR IMPORT/EXPORT
        const exportBtn = document.getElementById('export-btn');
        const importFileInput = document.getElementById('import-file-input');

        // Modal-Elemente
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // Link-Modal-Elemente
        const linkModalBackdrop = document.getElementById('link-modal-backdrop');
        const linkUrlInput = document.getElementById('link-url-input');
        const linkInsertBtn = document.getElementById('link-insert-btn');
        const linkCancelBtn = document.getElementById('link-cancel-btn');

        let notesData = [];
        let editingNoteId = null;
        let savedRange; // Zum Speichern der Auswahl
        let currentSortMethod = 'unsorted'; 

        // Speicherschlüssel als Konstante definieren
        const NOTES_STORAGE_KEY = 'notes';

        const colorMap = {
            'red': '#ff0000',
            'green': '#008000',
            'blue': '#3b82f6', // Etwas helleres Blau, das gut auf dem dunklen Hintergrund sichtbar ist
            'yellow': '#ffff00',
            'white': '#ffffff'
        };

        const sizeMap = {
            '1': 'Klein',
            '3': 'Mittel',
            '5': 'Groß'
        };

        // Drag-and-Drop-Variablen
        let draggedItem = null;


        // ******************************************************
        // ** HELPER FUNKTIONEN **
        // ******************************************************

        /**
         * Konvertiert einen RGB-Farbstring in einen Hex-String.
         * Nötig, da document.queryCommandValue('foreColor') oft RGB zurückgibt.
         */
        const rgbToHex = (rgb) => {
            const matches = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!matches) return rgb; // Wenn keine RGB-Daten, gib den ursprünglichen Wert zurück

            const hex = (x) => ("0" + parseInt(x).toString(16)).slice(-2);
            return "#" + hex(matches[1]) + hex(matches[2]) + hex(matches[3]);
        };


        // ******************************************************
        // ** MODAL LOGIK **
        // ******************************************************
        
        const showModal = (message, showCancelButton = false) => {
            return new Promise(resolve => {
                modalText.textContent = message;
                modalCancelBtn.style.display = showCancelButton ? 'inline-block' : 'none';
                modalBackdrop.classList.remove('hidden');

                const confirmHandler = () => {
                    modalBackdrop.classList.add('hidden');
                    resolve(true);
                };
                const cancelHandler = () => {
                    modalBackdrop.classList.add('hidden');
                    resolve(false);
                };

                modalConfirmBtn.onclick = confirmHandler;
                modalCancelBtn.onclick = cancelHandler;
            });
        };

        const showLinkModal = () => {
            return new Promise(resolve => {
                linkUrlInput.value = '';
                linkModalBackdrop.classList.remove('hidden');

                const insertHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(linkUrlInput.value);
                };
                const cancelHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(null);
                };

                // Einmalige Event Listener, um Konflikte zu vermeiden
                linkInsertBtn.onclick = insertHandler;
                linkCancelBtn.onclick = cancelHandler;
                
                // Fokus auf das Eingabefeld, sobald das Modal geöffnet wird
                linkUrlInput.focus();
            });
        };

        // ******************************************************
        // ** SELECTION/FOCUS LOGIK (WICHTIG für Toolbar) **
        // ******************************************************

        const getSelectionRange = () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                return selection.getRangeAt(0);
            }
            return null;
        };

        const saveSelection = () => {
            savedRange = getSelectionRange();
        };

        const restoreSelection = () => {
            if (savedRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedRange);
                savedRange = null;
            }
        };

        /**
         * Führt einen Formatierungsbefehl aus und stellt den Fokus in den Editor zurück.
         * @param {string} command - Der execCommand-Befehl.
         * @param {string} value - Der Wert für den execCommand-Befehl.
         */
        const executeFormatAndRestore = (command, value = null) => {
            // WICHTIG: Auswahl wiederherstellen und Fokus setzen VOR execCommand
            restoreSelection();
            noteEditor.focus();
            
            // Führe den Formatierungsbefehl aus
            document.execCommand(command, false, value);
            
            // Auswahl/Range erneut speichern, falls sich die Auswahl geändert hat
            saveSelection();
            
            // Toolbar-Status aktualisieren
            updateToolbarState();
        };
        
        // ******************************************************
        // ** SORTIER FUNKTIONEN **
        // ******************************************************

        /**
         * Sortiert die Notizen-Datenbank und rendert die Liste neu.
         * @param {string} method - Die Sortiermethode ('unsorted', 'newest', 'oldest', 'title-asc', 'title-desc').
         * @param {boolean} shouldSaveOrder - Soll die 'order'-Eigenschaft aktualisiert und gespeichert werden (true für manuelle Sortierung).
         */
        const sortNotes = (method, shouldSaveOrder = true) => {
            currentSortMethod = method;

            // Zuerst die Filterung anwenden
            const filteredNotes = notesData.filter(note => {
                const searchTerm = searchInput.value.toLowerCase();
                return note.title.toLowerCase().includes(searchTerm) || 
                       note.content.toLowerCase().includes(searchTerm);
            });
            
            // Sortierung anwenden
            if (method !== 'unsorted') {
                filteredNotes.sort((a, b) => {
                    if (method === 'newest') {
                        return new Date(b.createdAt) - new Date(a.createdAt);
                    } else if (method === 'oldest') {
                        return new Date(a.createdAt) - new Date(a.createdAt);
                    } else if (method === 'title-asc') {
                        return a.title.localeCompare(b.title);
                    } else if (method === 'title-desc') {
                        return b.title.localeCompare(a.title);
                    }
                });
            } else {
                 // Bei "Unsortiert" (manuell) nach der gespeicherten 'order'-Eigenschaft sortieren
                 filteredNotes.sort((a, b) => a.order - b.order);
            }

            // Aktualisiere den Button-Text
            const activeItem = sortDropdownMenu.querySelector(`.dropdown-item[data-value="${method}"]`);
            if (activeItem) {
                sortDropdownBtn.textContent = `Sortieren nach: ${activeItem.textContent}`;
                sortDropdownItems.forEach(item => item.classList.remove('active'));
                activeItem.classList.add('active');
            }

            // Neu rendern
            renderNotes();
        };

        // ******************************************************
        // ** CRUD / PERSISTENZ FUNKTIONEN **
        // ******************************************************

        const saveNotesToLocal = () => {
            try {
                // Nur die relevanten Daten speichern
                const dataToSave = notesData.map(note => ({
                    id: note.id,
                    title: note.title,
                    content: note.content,
                    createdAt: note.createdAt,
                    updatedAt: note.updatedAt,
                    order: note.order // Ordnung für manuelle Sortierung speichern
                }));
                localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(dataToSave));
            } catch (error) {
                console.error("Fehler beim Speichern der Notizen:", error);
                showModal("Ein Fehler ist beim Speichern Ihrer Notizen aufgetreten.");
            }
        };

        const loadNotesFromLocal = () => {
            loadingIndicator.classList.remove('hidden');
            try {
                const storedNotes = localStorage.getItem(NOTES_STORAGE_KEY);
                notesData = storedNotes ? JSON.parse(storedNotes) : [];
                
                // Sicherstellen, dass jede Notiz eine 'order' Eigenschaft hat (für Drag/Drop)
                notesData.forEach((note, index) => {
                    if (typeof note.order !== 'number') {
                         note.order = index;
                    }
                });
                
                // Stelle sicher, dass die 'unsorted' Sortierung nach 'order' korrekt ist
                sortNotes('unsorted', false);
            } catch (error) {
                console.error("Fehler beim Laden der Notizen:", error);
                notesData = []; // Fallback bei Fehler
            } finally {
                loadingIndicator.classList.add('hidden');
                renderNotes();
            }
        };

        const saveNote = () => {
            const title = noteTitleInput.value.trim();
            const content = noteEditor.innerHTML.trim();

            if (!title && !content) {
                showModal("Bitte geben Sie einen Titel oder Inhalt für Ihre Notiz ein.");
                return;
            }

            const now = new Date().toISOString();

            if (editingNoteId) {
                // Bearbeiten einer bestehenden Notiz
                const noteIndex = notesData.findIndex(note => note.id === editingNoteId);
                if (noteIndex !== -1) {
                    notesData[noteIndex] = {
                        ...notesData[noteIndex],
                        title: title,
                        content: content,
                        updatedAt: now
                    };
                }
                editingNoteId = null; // Bearbeitungsmodus beenden
                saveNoteBtn.textContent = 'Notiz speichern'; // Button-Text zurücksetzen
            } else {
                // Neue Notiz erstellen
                const newNote = {
                    id: crypto.randomUUID(),
                    title: title,
                    content: content,
                    createdAt: now,
                    updatedAt: now,
                    order: notesData.length > 0 ? notesData[notesData.length - 1].order + 1 : 0 // Neue Notiz kommt ans Ende
                };
                notesData.push(newNote);
            }
            
            // Editor leeren
            noteTitleInput.value = '';
            noteEditor.innerHTML = '';

            // Speichern und Rendern
            saveNotesToLocal();
            // Nach dem Speichern auf 'unsorted' (manuell) zurückwechseln, um die neue Notiz anzuzeigen
            sortNotes('unsorted', false);
            // setze Toolbar zurück
            updateToolbarState(); 
        };
        
        const editNote = (id, title, content) => {
            editingNoteId = id;
            noteTitleInput.value = title;
            noteEditor.innerHTML = content;
            saveNoteBtn.textContent = 'Änderungen speichern';
            // Scroll zum Editor
            window.scrollTo({ top: 0, behavior: 'smooth' });
            noteEditor.focus();
            updateToolbarState(); // Toolbar-Status aktualisieren
        };

        const deleteNote = async (id) => {
            const confirmed = await showModal("Sind Sie sicher, dass Sie diese Notiz löschen möchten?", true);
            if (confirmed) {
                notesData = notesData.filter(note => note.id !== id);
                // Wenn die gelöschte Notiz diejenige war, die gerade bearbeitet wird
                if (editingNoteId === id) {
                     editingNoteId = null;
                     noteTitleInput.value = '';
                     noteEditor.innerHTML = '';
                     saveNoteBtn.textContent = 'Notiz speichern';
                }
                saveNotesToLocal();
                sortNotes(currentSortMethod, false); // Neu rendern mit aktueller Sortierung
            }
        };
        
        // ******************************************************
        // ** IMPORT/EXPORT FUNKTIONEN **
        // ******************************************************

        /**
         * Exportiert alle Notizen als JSON-Datei.
         * Die Erfolgsmeldung wurde entfernt.
         */
        const exportNotes = () => {
            const dataStr = JSON.stringify(notesData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const exportFileDefaultName = 'meine_offline_notizen.json';

            let linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        };

        /**
         * Importiert Notizen aus einer JSON-Datei.
         */
        const importNotes = () => {
            const file = importFileInput.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!Array.isArray(importedData)) {
                        await showModal("Import fehlgeschlagen: Die Datei enthält keine gültige Notizen-Liste.");
                        return;
                    }

                    // Wir weisen allen importierten Notizen eine neue ID zu, um Kollisionen zu vermeiden, 
                    // ABER wir behalten die ursprünglichen Zeitstempel bei.
                    let newNotes = importedData.map(note => ({
                        id: crypto.randomUUID(), 
                        title: note.title || '',
                        content: note.content || '',
                        // ** KORREKTUR: Behalte die ursprünglichen Datumsangaben **
                        createdAt: note.createdAt && new Date(note.createdAt).toISOString() !== 'Invalid Date' ? note.createdAt : new Date().toISOString(),
                        updatedAt: note.updatedAt && new Date(note.updatedAt).toISOString() !== 'Invalid Date' ? note.updatedAt : new Date().toISOString(),
                        order: -1 
                    }));

                    // NEU: Import soll immer HINZUFÜGEN
                    notesData = [...notesData, ...newNotes];
                    
                    // Stelle sicher, dass 'order' für alle Notizen im unsortierten Zustand korrekt ist
                    notesData.forEach((note, index) => note.order = index);

                    saveNotesToLocal();
                    // Beim Import die Sortierung zurücksetzen
                    sortNotes('unsorted', false); 
                    renderNotes();
                    
                    // Behalte nur die Erfolgsmeldung für den Import
                    await showModal(`${importedData.length} Notizen erfolgreich importiert.`);
                    
                } catch (error) {
                    await showModal(`Fehler beim Importieren der Datei: ${error.message}`);
                } finally {
                    importFileInput.value = ''; // Eingabe zurücksetzen
                }
            };
            reader.readAsText(file);
        };
        
        // ******************************************************
        // ** RENDERING FUNKTIONEN **
        // ******************************************************

        const formatTimestamp = (isoString) => {
            const date = new Date(isoString);
            return date.toLocaleDateString('de-DE', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        };

        const renderNotes = (searchTerm = searchInput.value) => {
            // Filtern basierend auf dem Suchbegriff
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            const filteredAndSortedNotes = notesData
                // Schritt 1: Filtern
                .filter(note => {
                    return note.title.toLowerCase().includes(lowerCaseSearchTerm) || 
                           note.content.toLowerCase().includes(lowerCaseSearchTerm);
                });
                
            // Schritt 2: Sortieren (Verwendet die in sortNotes() festgelegte Reihenfolge/Sortierung)
            const notesToRender = currentSortMethod === 'unsorted' 
                ? filteredAndSortedNotes.sort((a, b) => a.order - b.order) // Nur 'unsorted' verwendet die manuelle Reihenfolge
                : filteredAndSortedNotes;
                
            // Das Rendern der gefilterten und sortierten Liste.
            notesList.innerHTML = ''; // Liste leeren

            if (notesData.length === 0) {
                noNotesMessage.classList.remove('hidden');
                searchInput.disabled = true;
                exportBtn.disabled = true;
                sortDropdownBtn.disabled = true;
                return;
            } else {
                noNotesMessage.classList.add('hidden');
                searchInput.disabled = false;
                exportBtn.disabled = false;
                sortDropdownBtn.disabled = false;
            }
            
            if (notesToRender.length === 0 && searchTerm) {
                notesList.innerHTML = `<p class="text-center text-gray-400 mt-8">Keine Notizen gefunden für "${searchTerm}".</p>`;
                return;
            } else if (notesToRender.length === 0) {
                noNotesMessage.classList.remove('hidden');
                return;
            }

            notesToRender.forEach(note => {
                const noteCard = createNoteCard(note);
                notesList.appendChild(noteCard);
            });
            
            // Wenn die Notizen sortiert sind, entferne die Drag-and-Drop-Listener
            if (currentSortMethod !== 'unsorted') {
                document.querySelectorAll('.note-card').forEach(card => {
                    card.removeAttribute('draggable');
                    card.classList.remove('cursor-grab');
                    card.removeEventListener('dragstart', handleDragStart);
                    card.removeEventListener('dragover', handleDragOver);
                    card.removeEventListener('drop', handleDrop);
                    card.removeEventListener('dragend', handleDragEnd);
                });
            }
        };

        const createNoteCard = (note) => {
            const div = document.createElement('div');
            div.className = 'note-card p-4 rounded-xl shadow-lg transition-all duration-300 transform hover:shadow-2xl flex flex-col relative';
            div.id = `note-${note.id}`;
            
            // Drag-and-Drop-Attribute nur bei unsortierter Ansicht hinzufügen
            if (currentSortMethod === 'unsorted') {
                div.setAttribute('draggable', 'true');
            } else {
                div.classList.remove('cursor-grab');
            }

            const isTitleEmpty = !note.title.trim();
            const titleHtml = isTitleEmpty 
                ? `<span class="text-gray-500 italic">Kein Titel</span>`
                : note.title;

            div.innerHTML = `
                <div class="flex-grow">
                    <h3 class="text-xl font-bold text-gray-100 mb-2">${titleHtml}</h3>
                    <div class="text-sm text-gray-300 mb-4 overflow-hidden" style="max-height: 200px;">
                        ${note.content}
                    </div>
                </div>
                <div class="flex items-center justify-between text-xs text-gray-500 border-t border-gray-700 pt-3 mt-auto">
                    <span>Erstellt: ${formatTimestamp(note.createdAt)}</span>
                    <span title="Zuletzt geändert">Geändert: ${formatTimestamp(note.updatedAt)}</span>
                </div>
                <div class="absolute top-4 right-4 flex space-x-2">
                    <button class="edit-btn calculator-btn note-action-btn bg-gray-600 hover:bg-gray-700">
                        ✏️
                    </button>
                    <button class="delete-btn calculator-btn note-action-btn bg-gray-600 hover:bg-gray-700">
                        🗑️
                    </button>
                </div>
            `;
            
            // Event Listener hinzufügen
            div.querySelector('.edit-btn').addEventListener('click', () => editNote(note.id, note.title, note.content));
            div.querySelector('.delete-btn').addEventListener('click', () => deleteNote(note.id));
            
            // Nur Drag-Listener hinzufügen, wenn Drag erlaubt ist
            if (currentSortMethod === 'unsorted') {
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
            }
            return div;
        };
        
        // ******************************************************
        // ** DRAG AND DROP (MANUELLE SORTIERUNG) FUNKTIONEN **
        // ******************************************************
        
        const handleDragStart = (e) => {
            draggedItem = e.target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.id); // Speichere die ID
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        };

        const handleDragOver = (e) => {
            if (e.dataTransfer.types.includes('text/plain')) {
                e.preventDefault(); 
                e.dataTransfer.dropEffect = 'move';
                
                const target = e.target.closest('.note-card');
                if (target && target !== draggedItem) {
                    const rect = target.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / rect.height > 0.5; // Oben oder unten?
                    notesList.insertBefore(draggedItem, next && target.nextSibling !== draggedItem ? target.nextSibling : target);
                }
            }
        };

        const handleDrop = (e) => {
            e.preventDefault();
            
            const target = e.target.closest('.note-card');
            if (target && target !== draggedItem) {
                 // Die tatsächliche DOM-Reihenfolge ist jetzt korrekt.
            }
        };

        const handleDragEnd = () => {
            draggedItem.classList.remove('dragging');
            
            // Aktualisiere die 'order'-Eigenschaft in notesData basierend auf der neuen DOM-Reihenfolge
            const newOrderIds = Array.from(notesList.children)
                                     .map(card => card.id.replace('note-', ''))
                                     .filter(id => id.length > 0);
            
            // Aktualisiere notesData.order basierend auf der neuen Reihenfolge
            const reorderedNotesData = [];
            newOrderIds.forEach((id, index) => {
                const note = notesData.find(n => n.id === id);
                if (note) {
                    note.order = index;
                    reorderedNotesData.push(note);
                }
            });
            
            // Wenn keine Suche aktiv ist, ist newOrderIds die neue Reihenfolge aller Notizen.
            if (!searchInput.value) {
                notesData = reorderedNotesData;
                saveNotesToLocal();
            } else {
                // Bei aktiver Suche/Filterung: Nur die order-Eigenschaft der sichtbaren Notizen wurde geändert.
                saveNotesToLocal();
            }

            draggedItem = null;
        };


        // ******************************************************
        // ** TOOLBAR FUNKTIONEN **
        // ******************************************************

        const updateToolbarState = () => {
            // Stelle sicher, dass wir im noteEditor sind
            if (document.activeElement !== noteEditor) {
                // Wenn der Fokus nicht im Editor ist, keine Aktualisierung vornehmen
                // ODER alle Buttons auf inaktiv setzen
                [boldBtn, italicBtn, underlineBtn, linkBtn, indentBtn, outdentBtn].forEach(btn => btn.classList.remove('active'));
                
                // Dropdowns auf Standard zurücksetzen/ausblenden
                listDropdownBtn.classList.remove('active');
                sizeDropdownBtn.textContent = "Schriftgröße";
                colorDropdownBtn.textContent = "Schriftfarbe";
                
                return;
            }

            // Textstil-Buttons
            boldBtn.classList.toggle('active', document.queryCommandState('bold'));
            italicBtn.classList.toggle('active', document.queryCommandState('italic'));
            underlineBtn.classList.toggle('active', document.queryCommandState('underline'));
            
            // Link-Button (wird aktiv, wenn die aktuelle Auswahl ein Link ist)
            linkBtn.classList.toggle('active', document.queryCommandState('createLink'));
            
            // Einrücken/Ausrücken Buttons (werden aktiv, wenn wir in einer Liste sind oder eingerückt sind)
            indentBtn.classList.toggle('active', document.queryCommandState('indent'));
            outdentBtn.classList.toggle('active', document.queryCommandState('outdent'));

            // Listen-Button (wird aktiv, wenn wir in einer Liste sind)
            listDropdownBtn.classList.toggle('active', document.queryCommandState('insertOrderedList') || document.queryCommandState('insertUnorderedList'));

            // Aktiven Listen-Typ im Dropdown hervorheben
            const isNumbered = document.queryCommandState('insertOrderedList');
            const isBulleted = document.queryCommandState('insertUnorderedList');
            
            listDropdownItems.forEach(item => item.classList.remove('active'));

            if (isNumbered) {
                 // Nummerierung
                 listDropdownMenu.querySelector('[data-value="decimal"]').classList.add('active');
            } else if (isBulleted) {
                // Versuche, den genauen Typ zu ermitteln (disc, circle)
                const parentList = getParentList(window.getSelection().anchorNode);
                let listStyleType = 'disc';
                if(parentList) {
                    listStyleType = parentList.style.listStyleType || 'disc';
                }
                
                const activeListItem = listDropdownMenu.querySelector(`[data-value="${listStyleType}"]`);
                if(activeListItem) {
                    activeListItem.classList.add('active');
                } else {
                    // Fallback auf disc
                    listDropdownMenu.querySelector('[data-value="disc"]').classList.add('active');
                }
            }
            

            // Schriftgröße
            let sizeValue = document.queryCommandValue('fontSize');
            if (sizeValue && sizeValue !== '0') {
                sizeValue = sizeValue.match(/\d+/)?.[0] || sizeValue; // CSS-Größe (z.B. 16px) in numerischen Wert umwandeln
                sizeDropdownBtn.textContent = `Größe: ${sizeMap[sizeValue] || sizeValue}`;
                
                sizeDropdownItems.forEach(item => item.classList.remove('active'));
                const activeSizeItem = sizeDropdownMenu.querySelector(`[data-value="${sizeValue}"]`);
                if (activeSizeItem) {
                    activeSizeItem.classList.add('active');
                }
            } else {
                sizeDropdownBtn.textContent = "Schriftgröße";
                sizeDropdownItems.forEach(item => item.classList.remove('active'));
                // Standardwert "Mittel" hervorheben
                 sizeDropdownMenu.querySelector('[data-value="3"]').classList.add('active');
            }

            // Schriftfarbe
            let colorValue = document.queryCommandValue('foreColor');
            if (colorValue && colorValue !== 'rgb(0, 0, 0)') {
                // Konvertiere RGB zu Hex, um es mit der colorMap abzugleichen
                const hexColor = colorValue.startsWith('rgb') ? rgbToHex(colorValue).toLowerCase() : colorValue.toLowerCase();
                
                const colorKey = Object.keys(colorMap).find(key => colorMap[key].toLowerCase() === hexColor);
                
                colorDropdownBtn.textContent = `Farbe: ${colorKey || 'Benutzerdef.'}`;
                
                colorDropdownItems.forEach(item => item.classList.remove('active'));
                if (colorKey) {
                    colorDropdownMenu.querySelector(`[data-value="${colorKey}"]`).classList.add('active');
                }
            } else {
                colorDropdownBtn.textContent = "Schriftfarbe";
                colorDropdownItems.forEach(item => item.classList.remove('active'));
                 // Standardwert "Weiß" hervorheben
                colorDropdownMenu.querySelector('[data-value="white"]').classList.add('active');
            }
        };

        const getParentList = (node) => {
            let parent = node;
            while(parent && parent !== noteEditor) {
                if(parent.nodeName === 'UL' || parent.nodeName === 'OL') {
                    return parent;
                }
                parent = parent.parentNode;
            }
            return null;
        };

        // ******************************************************
        // ** EVENT LISTENER **
        // ******************************************************
        
        // --- Toolbar Events ---
        boldBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            executeFormatAndRestore('bold');
        });
        italicBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            executeFormatAndRestore('italic');
        });
        underlineBtn.addEventListener('click', (e) => {
            e.preventDefault(); 
            executeFormatAndRestore('underline');
        });
        indentBtn.addEventListener('click', (e) => {
            e.preventDefault();
            executeFormatAndRestore('indent');
        });
        outdentBtn.addEventListener('click', (e) => {
            e.preventDefault();
            executeFormatAndRestore('outdent');
        });
        
        // Link-Funktionalität
        linkBtn.addEventListener('click', async (e) => {
            e.preventDefault(); 
            saveSelection();
            
            const isLinkActive = document.queryCommandState('createLink');
            
            if (isLinkActive) {
                // Link entfernen
                executeFormatAndRestore('unlink');
            } else {
                // Link erstellen
                const url = await showLinkModal();
                if (url) {
                    // WICHTIG: execCommand 'createLink' funktioniert nur, wenn Text ausgewählt ist.
                    // Die Auswahl wird in restoreSelection() wiederhergestellt.
                    executeFormatAndRestore('createLink', url);
                }
            }
        });

        // Dropdown Toggle
        const toggleDropdown = (btn, menu) => (e) => {
            e.stopPropagation();
            const isActive = menu.classList.contains('active');
            // Alle anderen Dropdowns schließen
            [listDropdownMenu, sizeDropdownMenu, colorDropdownMenu, sortDropdownMenu].forEach(m => m.classList.remove('active'));
            if (!isActive) {
                menu.classList.add('active');
            }
            // Toolbar-Status aktualisieren, da sich die Auswahl möglicherweise geändert hat
            updateToolbarState();
        };

        listDropdownBtn.addEventListener('click', toggleDropdown(listDropdownBtn, listDropdownMenu));
        sizeDropdownBtn.addEventListener('click', toggleDropdown(sizeDropdownBtn, sizeDropdownMenu));
        colorDropdownBtn.addEventListener('click', toggleDropdown(colorDropdownBtn, colorDropdownMenu));
        sortDropdownBtn.addEventListener('click', toggleDropdown(sortDropdownBtn, sortDropdownMenu));

        // Dropdown Items
        listDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            saveSelection();
            
            const listType = item.dataset.value;
            
            if (listType === 'decimal') {
                // OL verwenden
                document.execCommand('insertOrderedList', false, null);
                // Entferne alle UL/List-Style-Attribute
                const parentList = getParentList(window.getSelection().anchorNode);
                if(parentList) {
                    parentList.style.listStyleType = 'decimal';
                }
            } else {
                // UL verwenden und Stil setzen (disc oder circle)
                document.execCommand('insertUnorderedList', false, null);
                // Setze den Listentyp (disc, circle)
                const parentList = getParentList(window.getSelection().anchorNode);
                 if(parentList) {
                    parentList.style.listStyleType = listType;
                 }
            }
            
            executeFormatAndRestore('inserthtml', ''); // Führt restore, execCommand und updateState aus
            listDropdownMenu.classList.remove('active');
        }));

        sizeDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            executeFormatAndRestore('fontSize', item.dataset.value);
            sizeDropdownMenu.classList.remove('active');
        }));

        colorDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const colorKey = item.dataset.value;
            executeFormatAndRestore('foreColor', colorMap[colorKey]);
            colorDropdownMenu.classList.remove('active');
        }));
        
        sortDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            sortNotes(item.dataset.value);
            sortDropdownMenu.classList.remove('active');
        }));

        // Globale Klick-Events zum Schließen von Dropdowns
        document.addEventListener('click', () => {
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        
        // Speichern und Suchen
        saveNoteBtn.addEventListener('click', saveNote);
        searchInput.addEventListener('input', (e) => renderNotes(e.target.value));
        
        // Import/Export
        exportBtn.addEventListener('click', exportNotes);
        importFileInput.addEventListener('change', importNotes);
        
        // Event listener zur Aktualisierung des Toolbar-Zustands bei Fokuswechsel/Eingabe
        noteEditor.addEventListener('mouseup', saveSelection); // Speichern der Auswahl bei Mausklick
        noteEditor.addEventListener('keyup', saveSelection); // Speichern der Auswahl bei Tastendruck
        noteEditor.addEventListener('input', updateToolbarState);
        noteEditor.addEventListener('focus', updateToolbarState);
        noteEditor.addEventListener('blur', updateToolbarState);


        // Initial loading of notes
        window.addEventListener('load', loadNotesFromLocal);
    </script>
</body>
</html>
