/**
         * Helferfunktion: Findet das nächste Block-Level-Element (p, div, li, hx)
         * in Bezug auf den aktuellen Cursor innerhalb des noteEditor.
         */
        const getCurrentBlockElement = (selection) => {
            if (!selection.rangeCount) return null;
            let node = selection.getRangeAt(0).startContainer;

            // Wenn es ein Textknoten ist, gehe zum übergeordneten Element
            if (node.nodeType === Node.TEXT_NODE) {
                node = node.parentNode;
            }

            // Finde den nächsten Block-Level-Elternteil (P, DIV, LI)
            while (node && node !== noteEditor) {
                const tagName = node.tagName;
                if (['P', 'DIV', 'LI', 'H1', 'H2', 'H3'].includes(tagName)) {
                    return node;
                }
                node = node.parentNode;
            }
            // Fallback
            return noteEditor; 
        };

        /**
         * Führt die unabhängige Listenaktion pro Zeile durch (manuelle DOM-Manipulation).
         * @param {string} targetStyle - 'decimal', 'disc', 'circle'
         */
        const toggleCustomList = (targetStyle) => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            // Finde das aktuelle Block-Element
            const currentBlock = getCurrentBlockElement(selection);
            
            if (!currentBlock || currentBlock === noteEditor) {
                // Fallback für leere Zeile im Root: Erstelle ein P-Tag und rufe Funktion erneut auf
                document.execCommand('insertParagraph', false, null);
                const newP = getCurrentBlockElement(selection);
                if (newP && newP !== noteEditor) {
                    toggleCustomList(targetStyle); 
                }
                return;
            }
            
            const isCurrentlyLi = currentBlock.tagName === 'LI';
            let currentListType = null;
            let currentListStyle = 'none';

            if (isCurrentlyLi) {
                const parentList = currentBlock.parentNode;
                currentListType = parentList.tagName; // 'UL' or 'OL'
                currentListStyle = currentListType === 'OL' ? 'decimal' : (parentList.style.listStyleType || 'disc');
                if (currentListStyle === '') currentListStyle = 'disc';
            }

            // ------------------------------------
            // 1. ZIEL: DEAKTIVIERUNG (Toggle OFF)
            // ------------------------------------
            if (isCurrentlyLi && 
                ( (targetStyle === 'decimal' && currentListStyle === 'decimal') || 
                  (targetStyle === 'disc' && (currentListStyle === 'disc' || currentListStyle === '')) ||
                  (targetStyle === 'circle' && currentListStyle === 'circle') ) ) 
            {
                // Unliste das Element: Content in ein P-Tag zurückführen
                const content = currentBlock.innerHTML;
                const newBlock = document.createElement('p');
                newBlock.innerHTML = content;
                
                const parentList = currentBlock.parentNode;

                // Füge den neuen Block vor der Elternliste ein
                parentList.parentNode.insertBefore(newBlock, parentList);
                currentBlock.remove(); // Entferne das li
                
                // Aufräumen: Wenn die Elternliste jetzt leer ist, entferne sie
                if (parentList.children.length === 0) {
                    parentList.remove();
                }

                // Setze den Cursor zurück
                selection.removeAllRanges();
                const newRange = document.createRange();
                newRange.selectNodeContents(newBlock);
                newRange.collapse(false); 
                selection.addRange(newRange);
                
                return; // Aktion beendet
            }

            // ------------------------------------
            // 2. ZIEL: STIL-WECHSEL INNERHALB UL (disc <-> circle)
            // ------------------------------------
            if (isCurrentlyLi && currentListType === 'UL' && targetStyle !== 'decimal') {
                const parentList = currentBlock.parentNode;
                const targetMarkerStyle = targetStyle === 'disc' ? '' : targetStyle;
                
                // Ändere nur den Stil der Elternliste (der für diese einzelne LI-Zeile gilt)
                parentList.style.listStyleType = targetMarkerStyle;
                
                // Cursor wiederherstellen
                selection.removeAllRanges();
                const newRange = document.createRange();
                newRange.selectNodeContents(currentBlock);
                newRange.collapse(false);
                selection.addRange(newRange);
                return; // Aktion beendet
            }

            // ------------------------------------
            // 3. ZIEL: AKTIVIERUNG / TYP-WECHSEL (P/Div -> List, OL -> UL, UL -> OL)
            // ------------------------------------
            
            let elementToReplace = currentBlock;
            let contentToWrap = currentBlock.innerHTML;
            
            // 3a. Bei Listen-Wechsel (z.B. OL <-> UL), zuerst das LI auflösen.
            if (isCurrentlyLi) {
                const parentList = currentBlock.parentNode;
                
                // Speichere den Inhalt der Zeile
                contentToWrap = currentBlock.innerHTML;
                
                // Erstelle ein P-Tag (dies ist das elementToReplace nach dem Aufräumen)
                const tempP = document.createElement('p');
                tempP.innerHTML = contentToWrap;
                
                // Füge das P-Tag vor der Elternliste ein
                parentList.parentNode.insertBefore(tempP, parentList);
                
                // Entferne das LI
                currentBlock.remove();
                
                // Entferne die Elternliste, falls sie jetzt leer ist
                if (parentList.children.length === 0) {
                    parentList.remove();
                }
                
                elementToReplace = tempP;
            }
            
            // 3b. Erstellen der neuen Listenstruktur
            const listTag = targetStyle === 'decimal' ? 'OL' : 'UL';
            const newList = document.createElement(listTag);
            const newLi = document.createElement('li');
            
            newLi.innerHTML = contentToWrap || '<br>'; 
            newList.appendChild(newLi);

            // 3c. Style setzen (nur für UL)
            if (listTag === 'UL') {
                const targetMarkerStyle = targetStyle === 'disc' ? '' : targetStyle;
                newList.style.listStyleType = targetMarkerStyle;
            }
            
            // 3d. Ersetzen im DOM
            if (elementToReplace && elementToReplace.parentNode) {
                elementToReplace.parentNode.insertBefore(newList, elementToReplace);
                elementToReplace.remove();
            }
            
            // 3e. Cursor setzen
            selection.removeAllRanges();
            const newRange = document.createRange();
            newRange.selectNodeContents(newLi);
            newRange.collapse(false); // Cursor am Ende der Zeile
            selection.addRange(newRange);
        };
        
        // --- ENDE NEUE FUNKTIONEN ---

        // ** KORRIGIERTE LOGIK FÜR AUFZÄHLUNGSZEICHEN (3 TYPEN) - RUFT NEUE FUNKTION AUF **
        // DIESER BLOCK ERSETZT DIE KOMPLETTE VORHERIGE FOR-EACH-SCHLEIFE FÜR DIE LISTENBUTTONS
        listDropdownItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const listStyle = e.target.getAttribute('data-value'); // 'decimal', 'disc', 'circle'
                const selection = window.getSelection();
                
                if (!selection.rangeCount) return;
         
                listDropdownMenu.classList.remove('active');
                listDropdownBtn.blur(); 
                
                // styleWithCSS muss aktiv sein, da es für Farben/Größen/etc. benötigt wird
                document.execCommand('styleWithCSS', false, true); 
                
                // Führe die neue, unabhängige Listenaktion aus
                toggleCustomList(listStyle);
                
                // Beende styleWithCSS und aktualisiere den Zustand
                setTimeout(() => {
                    noteEditor.focus();
                    document.execCommand('styleWithCSS', false, false);
                    updateToolbarState(); 
                }, 1);
            });
        });
        // ** ENDE KORRIGIERTE LOGIK **
