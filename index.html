<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meine Offline-Notizen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root{
            /* BASICS */
            --btn-gray: #4b5563; /* bg-gray-600 */
            --btn-blue: #2563eb; /* bg-blue-600 */
            --btn-green: #10b981; /* bg-green-600 */
            --btn-yellow: #fbbf24; /* bg-yellow-600 */
            --accent: #6aa1ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            -webkit-tap-highlight-color: transparent;
            /* Versteckt Scrollbar auf iOS/MacOS, aber Scrollen ist möglich */
            overflow-x: hidden;
        }

        /* Hauptcontainer für Flex-Layout */
        .main-container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar für Notizenliste */
        #sidebar {
            width: 300px; /* Breite der Sidebar */
            flex-shrink: 0;
            background-color: #0d1117;
            border-right: 1px solid #2d3748;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Hauptbereich für Editor */
        #main-content {
            flex-grow: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            background-color: #000000;
        }

        /* Notizkarten-Stil */
        .note-card {
            background-color: #1a202c;
            border-color: #2d3748;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: grab;
            transition: all 0.1s ease;
            word-break: break-word; /* FIX: Verhindert Text-Überlauf */
            overflow-wrap: break-word; /* FIX: Verhindert Text-Überlauf */
        }
        .note-card:hover {
            background-color: #2d3748;
        }
        .note-card.active {
            border: 2px solid var(--accent);
        }
        .note-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        /* Editor-Stil */
        #note-editor {
            min-height: 250px;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            line-height: 1.6;
            outline: none;
            /* Überschreibt Standard-Browsereinstellungen */
            -webkit-user-modify: read-write-plaintext-only;
            user-modify: read-write-plaintext-only;
        }
        #note-editor:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px var(--accent);
        }

        /* Toolbar-Styling */
        .toolbar-btn, .dropdown-btn {
            background-color: var(--btn-gray);
            transition: all 0.1s;
        }
        .toolbar-btn:hover, .dropdown-btn:hover {
            background-color: #6b7280;
        }
        .toolbar-btn.active, .dropdown-btn.active {
            background-color: var(--accent);
            color: #000000; /* Textfarbe ändern für Kontrast */
        }
        .dropdown-item:hover {
            background-color: #374151;
        }
        .dropdown-item.active {
            background-color: var(--accent);
            color: #000000;
            font-weight: 700;
        }
        .dropdown-menu {
            z-index: 10;
        }
        
        /* Modal Backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .hidden {
            display: none !important;
        }
        
        /* Liste und Header Fixes */
        #note-editor ol, #note-editor ul {
            padding-left: 20px;
        }
        #note-editor h1, #note-editor h2, #note-editor h3 {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        /* Responsive Design: Mobile-First */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: 40vh; /* 40% der Viewport-Höhe */
                border-right: none;
                border-bottom: 1px solid #2d3748;
            }
            #main-content {
                height: 60vh; /* 60% der Viewport-Höhe */
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body class="bg-black text-gray-200">
    <div class="main-container">
        <div id="sidebar">
            <h1 class="text-2xl font-bold mb-4 text-white">Notizen</h1>
            
            <div class="flex space-x-2 mb-4">
                <button onclick="createNote()" class="flex-grow bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">
                    + Neu
                </button>
                <div class="relative">
                    <button id="sort-dropdown-btn" class="dropdown-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                        Sortieren
                    </button>
                    <div id="sort-dropdown-menu" class="dropdown-menu hidden absolute right-0 mt-2 w-40 bg-gray-800 rounded-lg shadow-xl z-20">
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="updated">Zuletzt bearbeitet</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="title">Titel (A-Z)</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700 active" data-value="unsorted">Manuelle Reihenfolge</a>
                    </div>
                </div>
            </div>
            
            <input id="search-input" type="text" placeholder="Notizen durchsuchen..." class="w-full mb-4 px-3 py-2 rounded-lg bg-gray-800 border border-gray-700 text-gray-200 focus:outline-none focus:border-blue-500">
            
            <div id="no-notes-message" class="text-center text-gray-500 py-4 hidden">
                Keine Notizen gefunden.
            </div>

            <div id="notes-list">
                </div>
        </div>

        <div id="main-content">
            <div class="flex justify-between items-center mb-4">
                <input id="note-title-input" type="text" placeholder="Titel der Notiz" class="flex-grow mr-4 text-3xl font-bold bg-transparent border-b border-gray-700 focus:outline-none focus:border-blue-500 text-white" disabled>
                
                <button id="save-note-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition duration-150 ease-in-out" disabled>
                    Speichern
                </button>
            </div>

            <div id="loading-indicator" class="text-center text-blue-500 mb-4 hidden">
                Speichern...
            </div>

            <div id="toolbar" class="flex flex-wrap items-center bg-gray-800 p-2 rounded-t-lg shadow-md mb-2">
                
                <button id="bold-btn" onclick="executeFormatAndRestore('bold')" class="toolbar-btn text-white p-2 rounded-lg mr-2 font-bold">B</button>
                <button id="italic-btn" onclick="executeFormatAndRestore('italic')" class="toolbar-btn text-white p-2 rounded-lg mr-2 font-serif italic">I</button>
                <button id="underline-btn" onclick="executeFormatAndRestore('underline')" class="toolbar-btn text-white p-2 rounded-lg mr-4 underline">U</button>

                <div class="relative mr-4">
                    <button id="list-dropdown-btn" class="dropdown-btn text-white p-2 rounded-lg flex items-center">
                        Aufzählung
                        <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="list-dropdown-menu" class="dropdown-menu hidden absolute mt-2 w-48 bg-gray-800 rounded-lg shadow-xl z-20">
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="disc" onclick="toggleCustomList('disc')">• Ungeordnet (Standard)</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="circle" onclick="toggleCustomList('circle')">○ Ungeordnet (Kreis)</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="decimal" onclick="toggleCustomList('decimal')">1. Nummeriert</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="formatBlock" onclick="executeFormatAndRestore('formatBlock', 'P')">Absatz (Entfernen)</a>
                    </div>
                </div>
                
                <button id="indent-btn" onclick="executeFormatAndRestore('indent')" class="toolbar-btn text-white p-2 rounded-lg mr-2" title="Einzug">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16M11 6h8M11 12h8M11 18h8"></path></svg>
                </button>
                <button id="outdent-btn" onclick="executeFormatAndRestore('outdent')" class="toolbar-btn text-white p-2 rounded-lg mr-4" title="Auszug">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16M3 6h1M3 12h1M3 18h1"></path></svg>
                </button>
                
                <button id="link-btn" onclick="executeLinkCommand()" class="toolbar-btn text-white p-2 rounded-lg mr-4" title="Link einfügen">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.832l4.14-4.14m1.562 1.562l4.14 4.14a4 4 0 005.656-5.656l-4-4a4 4 0 00-5.656 0l-1.1 1.1"></path></svg>
                </button>

                <div class="relative mr-4">
                    <button id="size-dropdown-btn" class="dropdown-btn text-white p-2 rounded-lg flex items-center">
                        Schriftgröße
                        <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="size-dropdown-menu" class="dropdown-menu hidden absolute mt-2 w-48 bg-gray-800 rounded-lg shadow-xl z-20">
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="1" onclick="executeFormatAndRestore('fontSize', 1)">Klein</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="3" onclick="executeFormatAndRestore('fontSize', 3)">Mittel (Standard)</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" data-value="5" onclick="executeFormatAndRestore('fontSize', 5)">Groß</a>
                    </div>
                </div>

                <div class="relative">
                    <button id="color-dropdown-btn" class="dropdown-btn text-white p-2 rounded-lg flex items-center">
                        Schriftfarbe
                        <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="color-dropdown-menu" class="dropdown-menu hidden absolute mt-2 w-48 bg-gray-800 rounded-lg shadow-xl z-20">
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" style="color: white;" data-value="white" onclick="executeFormatAndRestore('foreColor', '#ffffff')">Weiß (Standard)</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" style="color: red;" data-value="red" onclick="executeFormatAndRestore('foreColor', '#ff0000')">Rot</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" style="color: blue;" data-value="blue" onclick="executeFormatAndRestore('foreColor', '#3b82f6')">Blau</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" style="color: green;" data-value="green" onclick="executeFormatAndRestore('foreColor', '#008000')">Grün</a>
                        <a href="#" class="dropdown-item block px-4 py-2 text-sm text-gray-200 hover:bg-gray-700" style="color: yellow;" data-value="yellow" onclick="executeFormatAndRestore('foreColor', '#ffff00')">Gelb</a>
                    </div>
                </div>

            </div>

            <div id="note-editor" contenteditable="true" class="flex-grow rounded-b-lg mb-4" disabled>
                </div>
            
            <div class="mt-auto flex justify-end space-x-4 pt-4 border-t border-gray-700">
                <button id="export-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                    Notizen exportieren (.json)
                </button>
                <label for="import-file-input" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer">
                    Notizen importieren
                </label>
                <input type="file" id="import-file-input" accept=".json" class="hidden">
            </div>
        </div>

    </div>

    <div id="modal-backdrop" class="modal-backdrop hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-80">
            <p id="modal-text" class="text-white mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                    Abbrechen
                </button>
                <button id="modal-confirm-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">
                    Bestätigen
                </button>
            </div>
        </div>
    </div>
    
    <div id="link-modal-backdrop" class="modal-backdrop hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-96">
            <h3 class="text-white text-lg font-bold mb-3">Link einfügen</h3>
            <input id="link-url-input" type="url" placeholder="URL eingeben (z.B. https://example.com)" class="w-full px-3 py-2 rounded-lg bg-gray-700 border border-gray-600 text-gray-200 focus:outline-none focus:border-blue-500 mb-4">
            <div class="flex justify-end space-x-3">
                <button id="link-cancel-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                    Abbrechen
                </button>
                <button id="link-insert-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                    Einfügen
                </button>
            </div>
        </div>
    </div>

    <script>
        // DOM-Elemente
        const notesList = document.getElementById('notes-list');
        const noteTitleInput = document.getElementById('note-title-input');
        const noteEditor = document.getElementById('note-editor');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const searchInput = document.getElementById('search-input');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noNotesMessage = document.getElementById('no-notes-message');

        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const indentBtn = document.getElementById('indent-btn');
        const outdentBtn = document.getElementById('outdent-btn');
        const linkBtn = document.getElementById('link-btn');

        const listDropdownMenu = document.getElementById('list-dropdown-menu');
        const listDropdownBtn = document.getElementById('list-dropdown-btn');
        const listDropdownItems = listDropdownMenu.querySelectorAll('.dropdown-item');

        const sizeDropdownMenu = document.getElementById('size-dropdown-menu');
        const sizeDropdownBtn = document.getElementById('size-dropdown-btn');
        const sizeDropdownItems = sizeDropdownMenu.querySelectorAll('.dropdown-item');

        const colorDropdownMenu = document.getElementById('color-dropdown-menu');
        const colorDropdownBtn = document.getElementById('color-dropdown-btn');
        const colorDropdownItems = colorDropdownMenu.querySelectorAll('.dropdown-item');

        // Sortier-Elemente
        const sortDropdownBtn = document.getElementById('sort-dropdown-btn');
        const sortDropdownMenu = document.getElementById('sort-dropdown-menu');
        const sortDropdownItems = sortDropdownMenu.querySelectorAll('.dropdown-item');

        // KONSTANTEN FÜR IMPORT/EXPORT
        const exportBtn = document.getElementById('export-btn');
        const importFileInput = document.getElementById('import-file-input');

        // Modal-Elemente
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        
        // Link-Modal-Elemente
        const linkModalBackdrop = document.getElementById('link-modal-backdrop');
        const linkUrlInput = document.getElementById('link-url-input');
        const linkInsertBtn = document.getElementById('link-insert-btn');
        const linkCancelBtn = document.getElementById('link-cancel-btn');

        let notesData = [];
        let editingNoteId = null;
        let savedRange; // Zum Speichern der Auswahl
        let currentSortMethod = 'unsorted'; 

        // Speicherschlüssel als Konstante definieren
        const NOTES_STORAGE_KEY = 'notes'; 
        
        const colorMap = { 
            'red': '#ff0000', 
            'green': '#008000', 
            'blue': '#3b82f6', // Etwas helleres Blau, das gut auf dem dunklen Hintergrund sichtbar ist 
            'yellow': '#ffff00', 
            'white': '#ffffff' 
        }; 

        const sizeMap = { 
            '1': 'Klein', 
            '3': 'Mittel', 
            '5': 'Groß' 
        }; 

        // Drag-and-Drop-Variablen
        let draggedItem = null; 

        // ******************************************************
        // ** HELPER FUNKTIONEN **
        // ******************************************************
        
        /** * Konvertiert einen RGB-Farbstring in einen Hex-String. 
         * Nötig, da document.queryCommandValue('foreColor') oft RGB zurückgibt. 
         */ 
        const rgbToHex = (rgb) => { 
            const matches = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); 
            if (!matches) return rgb; // Wenn keine RGB-Daten, gib den ursprünglichen Wert zurück 
            const hex = (x) => ("0" + parseInt(x).toString(16)).slice(-2); 
            return "#" + hex(matches[1]) + hex(matches[2]) + hex(matches[3]); 
        }; 

        // ******************************************************
        // ** MODAL LOGIK **
        // ******************************************************
        
        const showModal = (message, showCancelButton = false) => { 
            return new Promise(resolve => { 
                modalText.textContent = message; 
                modalCancelBtn.style.display = showCancelButton ? 'inline-block' : 'none'; 
                modalBackdrop.classList.remove('hidden'); 
                
                const confirmHandler = () => { 
                    modalBackdrop.classList.add('hidden'); 
                    resolve(true); 
                }; 
                
                const cancelHandler = () => { 
                    modalBackdrop.classList.add('hidden'); 
                    resolve(false); 
                }; 
                
                modalConfirmBtn.onclick = confirmHandler; 
                modalCancelBtn.onclick = cancelHandler; 
            }); 
        }; 

        const showLinkModal = () => { 
            return new Promise(resolve => { 
                linkUrlInput.value = ''; 
                linkModalBackdrop.classList.remove('hidden'); 
                
                const insertHandler = () => { 
                    linkModalBackdrop.classList.add('hidden'); 
                    resolve(linkUrlInput.value); 
                }; 
                
                const cancelHandler = () => { 
                    linkModalBackdrop.classList.add('hidden'); 
                    resolve(null); 
                }; 
                
                // Einmalige Event Listener, um Konflikte zu vermeiden 
                linkInsertBtn.onclick = insertHandler; 
                linkCancelBtn.onclick = cancelHandler; 
                
                // Fokus auf das Eingabefeld, sobald das Modal geöffnet wird 
                linkUrlInput.focus(); 
            }); 
        }; 

        // ******************************************************
        // ** SELECTION/FOCUS LOGIK (WICHTIG für Toolbar) **
        // ******************************************************
        
        const getSelectionRange = () => { 
            const selection = window.getSelection(); 
            if (selection.rangeCount > 0) { 
                return selection.getRangeAt(0); 
            } 
            return null; 
        }; 

        const saveSelection = () => { 
            savedRange = getSelectionRange(); 
        }; 

        const restoreSelection = () => { 
            if (savedRange) { 
                const selection = window.getSelection(); 
                selection.removeAllRanges(); 
                selection.addRange(savedRange); 
            } 
        }; 
        
        const collapseSelection = () => { 
            const selection = window.getSelection(); 
            if (selection.rangeCount > 0) { 
                const range = selection.getRangeAt(0); 
                // collapse auf das Ende, um den Cursor zu positionieren 
                range.collapse(false); 
                selection.removeAllRanges(); 
                selection.addRange(range); 
            } 
        }; 

        // ******************************************************
        // ** KORRIGIERTE executeFormatAndRestore FUNKTION **
        // ******************************************************
        const executeFormatAndRestore = (command, value = null) => { 
            // 1. Auswahl wiederherstellen
            restoreSelection(); 
            
            // 2. Führe den Formatierungsbefehl aus
            document.execCommand(command, false, value);
            
            // FIX 1 (AGGGRESSIV): Erzwingt einen HTML-Block (<p>) im leeren Editor, 
            // um den Zustand für den nächsten Klick zu stabilisieren (löst Toggling- und Leer-Editor-Fehler).
            if (!noteEditor.textContent.trim() && (command === 'bold' || command === 'italic' || command === 'underline')) {
                 document.execCommand('formatBlock', false, 'p'); 
            }
            
            // 3. Statusaktualisierung mit minimaler Verzögerung (Timeout-Fix)
            setTimeout(() => {
                noteEditor.focus(); 
                saveSelection();
                updateToolbarState(); 
            }, 0); 
        }; 

        const executeLinkCommand = async () => { 
            // 1. Auswahl speichern 
            saveSelection(); 
            
            // 2. Modal anzeigen und auf URL warten 
            const url = await showLinkModal(); 
            
            // 3. Auswahl wiederherstellen 
            restoreSelection(); 

            if (url) { 
                // Führt den Link-Befehl aus und ersetzt die aktuelle Auswahl 
                document.execCommand('createLink', false, url); 
                
                // Manuelle Korrektur für target="_blank" 
                const selection = window.getSelection(); 
                const node = selection.anchorNode; 
                
                // Versuche, das umgebende A-Tag zu finden 
                let linkElement = node.nodeType === Node.TEXT_NODE ? node.parentNode : node; 
                while (linkElement && linkElement !== noteEditor && linkElement.tagName !== 'A') { 
                    linkElement = linkElement.parentNode; 
                } 
                
                if (linkElement && linkElement.tagName === 'A') { 
                    linkElement.setAttribute('target', '_blank'); 
                } 
            } 
            
            // 4. Fokus in den Editor zurücksetzen 
            noteEditor.focus(); 
            updateToolbarState(); 
        }; 

        // ******************************************************
        // ** AUFZÄHLUNGSLOGIK **
        // ******************************************************
        
        /** * Findet das nächste Block-Level-Element (p, div, li, hx) 
         * in Bezug auf den aktuellen Cursor innerhalb des noteEditor. 
         */ 
        const getCurrentBlockElement = (selection) => { 
            if (!selection.rangeCount) return null; 
            let node = selection.getRangeAt(0).startContainer; 
            
            // Wenn es ein Textknoten ist, gehe zum übergeordneten Element 
            if (node.nodeType === Node.TEXT_NODE) { 
                node = node.parentNode; 
            } 
            
            // Finde den nächsten Block-Level-Elternteil (P, DIV, LI) 
            while (node && node !== noteEditor) { 
                const tagName = node.tagName; 
                // Füge DIV hinzu, falls der Editor ein leeres DIV erstellt (z.B. bei Enter) 
                if (['P', 'DIV', 'LI', 'H1', 'H2', 'H3'].includes(tagName)) { 
                    return node; 
                } 
                node = node.parentNode; 
            } 
            return null; 
        }; 

        /** * Wendet eine benutzerdefinierte Listenformatierung (ul/ol mit Stil) an. 
         * @param {string} targetStyle - 'decimal', 'disc', 'circle' 
         */ 
        const toggleCustomList = (targetStyle) => { 
            restoreSelection(); 
            
            const currentBlock = getCurrentBlockElement(window.getSelection());
            
            if (targetStyle === 'decimal') {
                // Nummerierte Liste
                document.execCommand('insertOrderedList');
            } else if (targetStyle === 'disc' || targetStyle === 'circle') {
                // Ungeordnete Liste
                document.execCommand('insertUnorderedList');
            }

            // Nach der Anwendung der Liste den Stil setzen
            setTimeout(() => {
                const newBlock = getCurrentBlockElement(window.getSelection());
                if (newBlock && (newBlock.tagName === 'UL' || (newBlock.tagName === 'LI' && newBlock.parentNode.tagName === 'UL'))) {
                    // Finde das UL-Elternteil
                    let ulElement = newBlock.tagName === 'UL' ? newBlock : newBlock.parentNode;
                    
                    // Entferne alle alten Stile
                    ulElement.style.listStyleType = '';
                    
                    // Setze den neuen Stil, außer bei 'disc' (Standard)
                    if (targetStyle === 'circle') {
                        ulElement.style.listStyleType = 'circle';
                    } 
                }
                
                noteEditor.focus();
                saveSelection();
                updateToolbarState();
            }, 0);
        }; 

        // ******************************************************
        // ** KORRIGIERTE TOOLBAR AKTUALISIERUNG (ACTIVE MARKER) LOGIK **
        // ******************************************************
        
        const updateToolbarState = () => {
            const selection = window.getSelection();

            // FÜR FOKUS/CURSOR RÜCKKEHR: Speichere die Auswahl bei MouseUp oder KeyUp
            if (document.activeElement === noteEditor) {
                saveSelection();
            }

            // FIX 2a: Der zerstörerische Reset-Block am Anfang wurde entfernt. 
            // Hier war der Fehler, der alle Buttons deaktiviert hat.
            if (selection.rangeCount === 0 || !noteEditor.contains(selection.anchorNode)) {
                // Nur Dropdowns de-aktivieren
                document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
                
                // Reset Dropdown Button Text
                listDropdownBtn.textContent = 'Aufzählung';
                sizeDropdownBtn.textContent = 'Schriftgröße';
                colorDropdownBtn.textContent = 'Schriftfarbe';
                // Der 'return' Befehl wurde hier entfernt, damit die B/I/U Statusprüfung immer läuft.
            }

            // Text-Formate (B/I/U/Link)
            // FIX 2b: Separate if/else-Logik für gleichzeitige Aktivierung
            
            // BOLD
            if (document.queryCommandState('bold')) {
                boldBtn.classList.add('active'); 
            } else {
                boldBtn.classList.remove('active');
            }

            // ITALIC
            if (document.queryCommandState('italic')) {
                italicBtn.classList.add('active'); 
            } else {
                italicBtn.classList.remove('active');
            }

            // UNDERLINE
            if (document.queryCommandState('underline')) {
                underlineBtn.classList.add('active'); 
            } else {
                underlineBtn.classList.remove('active');
            }

            // Link kann toggle beibehalten
            linkBtn.classList.toggle('active', document.queryCommandState('createLink'));

            // Listen-Formate (Dropdown Active Marker FIX)
            listDropdownItems.forEach(item => item.classList.remove('active')); 

            const currentBlock = getCurrentBlockElement(selection); 

            if (currentBlock) { 
                // 1. Listen-Typ prüfen (UL, OL) 
                let listType = null; 
                if (currentBlock.tagName === 'LI') { 
                    const parent = currentBlock.parentNode; 
                    listType = parent.tagName; 
                    
                    // 2. Spezifischen Stil prüfen (disc, circle, decimal) 
                    const style = parent.style.listStyleType; 
                    if (parent.tagName === 'UL' && style === 'circle') { 
                        listType = 'circle'; // Spezieller Marker für circle 
                    } else if (parent.tagName === 'UL') { 
                        listType = 'disc'; // Spezieller Marker für disc 
                    } else if (parent.tagName === 'OL') { 
                        listType = 'decimal'; // Spezieller Marker für ol 
                    } 
                } 

                // 3. Setze den aktiven Marker im Dropdown 
                listDropdownItems.forEach(item => { 
                    const itemValue = item.dataset.value; 
                    if (itemValue === listType) { 
                        item.classList.add('active'); 
                        listDropdownBtn.textContent = item.textContent; 
                    } 
                }); 
                
                // Schriftgröße prüfen 
                let sizeValue = document.queryCommandValue('fontSize'); 
                if (sizeValue && sizeValue !== '2') { // '2' ist die Standardgröße 
                    sizeDropdownItems.forEach(item => { 
                        if (item.dataset.value === sizeValue) { 
                            item.classList.add('active'); 
                            sizeDropdownBtn.textContent = item.textContent; 
                        } 
                    }); 
                } else { 
                    sizeDropdownBtn.textContent = 'Schriftgröße'; 
                } 
                
                // Schriftfarbe prüfen 
                let colorValue = document.queryCommandValue('foreColor').toLowerCase(); 
                // Konvertiere RGB zu HEX, falls nötig 
                if (colorValue.startsWith('rgb')) { 
                    colorValue = rgbToHex(colorValue); 
                } 

                if (colorValue && colorValue !== '#000000' && colorValue !== '#e2e8f0') { 
                    // Suche den passenden Button anhand des HEX-Wertes 
                    const matchingColor = Object.keys(colorMap).find(key => colorMap[key] === colorValue); 
                    if (matchingColor) { 
                        colorDropdownItems.forEach(item => { 
                            if (item.dataset.value === matchingColor) { 
                                item.classList.add('active'); 
                                colorDropdownBtn.textContent = item.textContent; 
                            } 
                        }); 
                    } 
                } else { 
                    colorDropdownBtn.textContent = 'Schriftfarbe'; 
                } 

            } else {
                // Fallback, wenn kein Block gefunden wird (z.B. im leeren Editor nach einem Klick)
                listDropdownBtn.textContent = 'Aufzählung';
                sizeDropdownBtn.textContent = 'Schriftgröße';
                colorDropdownBtn.textContent = 'Schriftfarbe';
            }
        };

        // ******************************************************
        // ** NOTIZEN SPEICHERN, LADEN UND RENDERN **
        // ******************************************************
        
        const loadNotesFromLocal = () => { 
            const storedNotes = localStorage.getItem(NOTES_STORAGE_KEY); 
            notesData = storedNotes ? JSON.parse(storedNotes) : []; 
            renderNotes(); 
        }; 

        const saveNotesToLocal = () => { 
            localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notesData)); 
        }; 

        const createNote = () => { 
            const newNote = { 
                id: Date.now().toString(), 
                title: 'Neue Notiz', 
                content: '', 
                created: Date.now(), 
                updated: Date.now(), 
                isNew: true // Markiert als neue Notiz, bis gespeichert 
            }; 
            notesData.unshift(newNote); 
            saveNotesToLocal(); 
            editNote(newNote.id); 
            renderNotes(); 
        }; 

        const saveNote = () => { 
            // Füge einen leeren Block am Ende hinzu, falls der Editor komplett leer ist 
            if (noteEditor.innerHTML === '') { 
                noteEditor.innerHTML = '<p><br></p>'; 
            } 

            const title = noteTitleInput.value.trim(); 
            const content = noteEditor.innerHTML; 

            if (!title && !content) { 
                showModal("Die Notiz ist leer und wird nicht gespeichert.").then(() => { 
                    if (editingNoteId) { 
                        // Entferne die leere Notiz, wenn sie bearbeitet wurde 
                        notesData = notesData.filter(note => note.id !== editingNoteId); 
                        saveNotesToLocal(); 
                        renderNotes(); 
                    } 
                    resetEditor(); 
                }); 
                return; 
            } 

            if (editingNoteId) { 
                const note = notesData.find(n => n.id === editingNoteId); 
                if (note) { 
                    note.title = title || 'Unbenannt'; 
                    note.content = content; 
                    note.updated = Date.now(); 
                    note.isNew = false; 
                } 
            } else { 
                // Dies sollte nicht passieren, da createNote immer zuerst aufgerufen wird 
                console.error("Speichern einer Notiz ohne editingNoteId"); 
                return; 
            } 

            saveNotesToLocal(); 
            resetEditor(); 
            renderNotes(); 
            // Blende Ladeanzeige für 1 Sekunde ein 
            loadingIndicator.classList.remove('hidden'); 
            setTimeout(() => { 
                loadingIndicator.classList.add('hidden'); 
            }, 1000); 
        }; 

        const deleteNote = async (id) => { 
            const confirmed = await showModal("Möchten Sie diese Notiz wirklich löschen?", true); 
            if (confirmed) { 
                notesData = notesData.filter(note => note.id !== id); 
                saveNotesToLocal(); 
                if (editingNoteId === id) { 
                    resetEditor(); 
                } 
                renderNotes(); 
            } 
        }; 

        const editNote = (id) => { 
            // Deaktiviere alle anderen aktiven Notizkarten
            document.querySelectorAll('.note-card.active').forEach(card => card.classList.remove('active'));

            const note = notesData.find(n => n.id === id); 
            if (note) { 
                editingNoteId = id; 
                noteTitleInput.value = note.title; 
                noteEditor.innerHTML = note.content; 
                noteTitleInput.disabled = false; 
                noteEditor.contentEditable = 'true'; 
                saveNoteBtn.disabled = false; 
                
                // Aktiviere die aktuelle Karte
                const card = document.querySelector(`.note-card[data-id="${id}"]`);
                if(card) {
                    card.classList.add('active');
                }
                
                // Setze den Fokus ans Ende des Editors und aktualisiere die Toolbar
                noteEditor.focus();
                collapseSelection();
                updateToolbarState(); 
            } 
        }; 

        const resetEditor = () => { 
            editingNoteId = null; 
            noteTitleInput.value = ''; 
            noteEditor.innerHTML = ''; 
            noteTitleInput.disabled = true; 
            noteEditor.contentEditable = 'false'; 
            saveNoteBtn.disabled = true; 
            savedRange = null; // Auswahl zurücksetzen
            
            // Deaktiviere alle Buttons
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
            listDropdownBtn.textContent = 'Aufzählung';
            sizeDropdownBtn.textContent = 'Schriftgröße';
            colorDropdownBtn.textContent = 'Schriftfarbe';
            
            // Deaktiviere alle Notizkarten
            document.querySelectorAll('.note-card.active').forEach(card => card.classList.remove('active'));
        }; 

        const sortNotes = (method) => {
            currentSortMethod = method;
            
            if (method === 'updated') {
                notesData.sort((a, b) => b.updated - a.updated);
            } else if (method === 'title') {
                notesData.sort((a, b) => a.title.localeCompare(b.title));
            } else if (method === 'unsorted') {
                // Keine Sortierung, behält die aktuelle Reihenfolge (Drag/Drop)
            }
            
            saveNotesToLocal();
            renderNotes();

            // Aktiven Marker im Dropdown setzen
            sortDropdownItems.forEach(item => item.classList.remove('active'));
            document.querySelector(`#sort-dropdown-menu .dropdown-item[data-value="${method}"]`).classList.add('active');
        };

        const renderNotes = (searchTerm = searchInput.value) => { 
            const notes = notesData.filter(note => 
                !searchTerm || 
                note.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
                note.content.toLowerCase().includes(searchTerm.toLowerCase()) 
            ); 

            notesList.innerHTML = ''; 
            
            if (notes.length === 0) {
                noNotesMessage.classList.remove('hidden');
            } else {
                noNotesMessage.classList.add('hidden');
            }

            notes.forEach(note => { 
                const div = document.createElement('div'); 
                div.className = `note-card relative ${note.id === editingNoteId ? 'active' : ''}`; 
                div.draggable = currentSortMethod === 'unsorted'; // Nur bei "Manuelle Reihenfolge" verschiebbar
                div.dataset.id = note.id; 
                div.innerHTML = ` 
                    <h3 class="text-lg font-semibold text-white mb-1">${note.title || 'Unbenannt'}</h3> 
                    <div class="text-sm text-gray-400 overflow-hidden max-h-12">${note.content || '...'}</div> 
                    <p class="text-xs text-gray-500 mt-2">Zuletzt bearbeitet: ${new Date(note.updated).toLocaleDateString()}</p> 
                    <button class="delete-btn absolute top-2 right-2 text-red-500 hover:text-red-400 p-1 rounded-full bg-gray-700/50 hover:bg-gray-700 leading-none" title="Notiz löschen"> 
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg> 
                    </button> 
                `; 

                div.addEventListener('click', () => editNote(note.id)); 
                div.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation(); // Verhindert, dass das editNote-Event ausgelöst wird
                    deleteNote(note.id);
                });

                // Nur Drag-Listener hinzufügen, wenn Drag erlaubt ist
                if (currentSortMethod === 'unsorted') {
                    div.addEventListener('dragstart', handleDragStart);
                    div.addEventListener('dragover', handleDragOver);
                    div.addEventListener('drop', handleDrop);
                    div.addEventListener('dragend', handleDragEnd);
                }

                notesList.appendChild(div); 
            }); 
        }; 

        // ******************************************************
        // ** DRAG & DROP LOGIK **
        // ******************************************************

        const handleDragStart = (e) => {
            draggedItem = e.target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Dummy-Daten
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        };

        const handleDragOver = (e) => {
            e.preventDefault(); // Ermöglicht das Ablegen
            e.dataTransfer.dropEffect = 'move';

            const target = e.target.closest('.note-card');
            if (target && target !== draggedItem) {
                const rect = target.getBoundingClientRect();
                const middleY = rect.top + rect.height / 2;

                // Füge eine visuelle Trennlinie ein (optional, aber hilfreich)
                if (e.clientY < middleY) {
                    notesList.insertBefore(draggedItem, target);
                } else {
                    notesList.insertBefore(draggedItem, target.nextSibling);
                }
            }
        };

        const handleDrop = (e) => {
            e.preventDefault();
            draggedItem.classList.remove('dragging');
            
            if (draggedItem.parentNode === notesList) {
                // Aktualisiere die interne notesData-Reihenfolge basierend auf dem DOM
                const newOrderIds = Array.from(notesList.children).map(child => child.dataset.id);
                
                const reorderedNotes = newOrderIds.map(id => notesData.find(note => note.id === id));
                notesData = reorderedNotes.filter(n => n); // Filtert undefined/null
                saveNotesToLocal();
            }
        };

        const handleDragEnd = () => {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
        };

        // ******************************************************
        // ** IMPORT/EXPORT LOGIK **
        // ******************************************************

        const exportNotes = () => {
            const dataStr = JSON.stringify(notesData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

            const exportFileDefaultName = 'offline_notes.json';

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        };

        const importNotes = (e) => {
            const file = e.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    if (Array.isArray(importedData)) {
                        const confirmed = await showModal("Möchten Sie die aktuellen Notizen mit den importierten Notizen überschreiben? Dies kann nicht rückgängig gemacht werden.", true);
                        if (confirmed) {
                            notesData = importedData;
                            saveNotesToLocal();
                            renderNotes();
                            showModal("Import erfolgreich!");
                        }
                    } else {
                        showModal("Import fehlgeschlagen: Die Datei enthält keine gültige Notizenliste.");
                    }
                } catch (error) {
                    showModal("Import fehlgeschlagen: Ungültiges JSON-Format.");
                    console.error("Import error:", error);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Setzt den Input zurück
        };

        // ******************************************************
        // ** EVENT LISTENER REGISTRIERUNG **
        // ******************************************************

        // Schaltet Dropdowns um
        listDropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); listDropdownMenu.classList.toggle('hidden'); });
        sizeDropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); sizeDropdownMenu.classList.toggle('hidden'); });
        colorDropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); colorDropdownMenu.classList.toggle('hidden'); });
        sortDropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); sortDropdownMenu.classList.toggle('hidden'); });

        // Schließt Dropdowns, wenn außerhalb geklickt wird
        document.addEventListener('click', () => {
            listDropdownMenu.classList.add('hidden');
            sizeDropdownMenu.classList.add('hidden');
            colorDropdownMenu.classList.add('hidden');
            sortDropdownMenu.classList.add('hidden');
        });

        // Verhindert, dass Klicks in Dropdown-Menüs die Menüs schließen
        [listDropdownMenu, sizeDropdownMenu, colorDropdownMenu, sortDropdownMenu].forEach(menu => {
            menu.addEventListener('click', (e) => e.stopPropagation());
            menu.querySelectorAll('.dropdown-item').forEach(item => item.addEventListener('click', (e) => {
                e.stopPropagation();
                // Spezielle Logik für Sortieren (um den Zustand zu aktualisieren)
                if (menu.id === 'sort-dropdown-menu') {
                    sortNotes(item.dataset.value);
                }
                menu.classList.add('hidden'); // Schließt das Menü nach Auswahl
            }));
        });
        
        // Speichern und Suchen
        saveNoteBtn.addEventListener('click', saveNote);
        searchInput.addEventListener('input', (e) => renderNotes(e.target.value));
        
        // Import/Export
        exportBtn.addEventListener('click', exportNotes);
        importFileInput.addEventListener('change', importNotes);
        
        // ******************************************************
        // FIX 3: Event listener zur Aktualisierung des Toolbar-Zustands
        // ******************************************************
        noteEditor.addEventListener('mouseup', updateToolbarState); // FIX: Ruft den Status sofort ab

        noteEditor.addEventListener('keyup', () => {
            saveSelection(); // Speichert die Auswahl
            updateToolbarState(); // Aktualisiert den Zustand
        }); 

        // Bei input nur Auswahl speichern, da keyup/mouseup den Status aktualisiert
        noteEditor.addEventListener('input', saveSelection); 
        noteEditor.addEventListener('focus', updateToolbarState);
        noteEditor.addEventListener('blur', updateToolbarState);

        // Initial loading of notes
        window.addEventListener('load', loadNotesFromLocal);
    </script>
</body>
</html>
