<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meine Offline-Notizen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root{
            /* BASICS */
            --btn-gray: #4b5563; /* bg-gray-600 */
            --btn-blue: #2563eb; /* bg-blue-600 */
            --btn-green: #10b981; /* bg-green-600 */
            --btn-yellow: #fbbf24; /* bg-yellow-600 */
            --accent: #6aa1ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            -webkit-tap-highlight-color: transparent;
        }

        .note-card {
            background-color: #1a202c;
            border-color: #2d3748;
            cursor: grab;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .note-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        #note-editor {
            min-height: 100px;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid #4a5568; 
            background-color: #1a202c;
            color: #ffffff;
            outline: none; 
            transition: all 0.3s;
        }
        
        #note-editor:focus {
            outline: none !important;
        }

        /* ----------------------------------------------------- */
        /* --- RECHNER-PRINZIP CSS-REGELN FÜR ALLE BUTTONS --- */
        /* ----------------------------------------------------- */
        .calculator-btn, label[for="import-file-input"] {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: transform .06s ease, background-color 0.2s ease;
            border: none;
        }

        /* FIX 1: Klick-Animation (Scale-Down) mit !important für maximale Priorität */
        .calculator-btn:active, 
        label[for="import-file-input"]:active,
        #indent-btn:active, /* Explizit hinzugefügt, falls die generische Regel nicht ausreicht */
        #outdent-btn:active {
            transform: scale(0.96) !important; 
        }

        .calculator-btn:focus, label[for="import-file-input"]:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        .calculator-btn:focus-visible, label[for="import-file-input"]:focus-visible {
            outline: 2px solid var(--accent); 
            outline-offset: 2px;
        }
        
        /* Graue Buttons (Toolbar, Sort, Modal-Cancel) */
        .toolbar-btn, .dropdown-item, #sort-dropdown-btn, #modal-cancel-btn, #link-cancel-btn {
            background-color: var(--btn-gray) !important;
        }
        
        .toolbar-btn:hover:not(.active), .dropdown-item:hover:not(.active), #sort-dropdown-btn:hover, #modal-cancel-btn:hover, #link-cancel-btn:hover {
            background-color: #55606e !important; /* Etwas dunkler als 4b5563, aber heller als active */
        }
        
        .toolbar-btn:active, .dropdown-item:active, #sort-dropdown-btn:active, #modal-cancel-btn:active, #link-cancel-btn:active {
             background-color: #374151 !important; /* bg-gray-700 */
        }

        /* WICHTIG: Blauer Hintergrund für aktive Toolbar-Buttons und Dropdown-Elemente */
        .toolbar-btn.active, .dropdown-item.active {
            background-color: var(--btn-blue) !important;
            color: #ffffff !important;
        }

        /* Blaue Buttons (Save, Modal-Confirm, Link-Insert) */
        #save-note-btn, #modal-confirm-btn, #link-insert-btn {
            background-color: var(--btn-blue) !important;
        }
        #save-note-btn:hover, #modal-confirm-btn:hover, #link-insert-btn:hover {
            background-color: #1d4ed8 !important; /* bg-blue-700 */
        }
        #save-note-btn:active, #modal-confirm-btn:active, #link-insert-btn:active {
            background-color: #1e40af !important; /* bg-blue-800 */
        }

        /* Grüne Buttons (Export) */
        #export-btn {
            background-color: var(--btn-green) !important;
        }
        #export-btn:hover {
            background-color: #059669 !important; /* bg-green-700 */
        }
        #export-btn:active {
            background-color: #047857 !important; /* bg-green-800 */
        }
        
        /* Gelbe Buttons (Import) */
        label[for="import-file-input"] {
            background-color: var(--btn-yellow) !important;
        }
        label[for="import-file-input"]:hover {
             background-color: #f59e0b !important; /* bg-yellow-600/700 */
        }
        label[for="import-file-input"]:active {
            background-color: #a16207 !important; /* bg-yellow-800 */
        }
        
        /* Dropdown Menü Styling */
        .dropdown-menu {
            position: absolute;
            z-index: 10;
            top: 100%;
            left: 0;
            margin-top: 0.5rem;
            background-color: #374151; /* bg-gray-700 */
            border-radius: 0.5rem;
            padding: 0.25rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            width: max-content;
            min-width: 100%;
        }

        .dropdown-menu.active {
            display: flex;
        }

        #note-editor:empty:before {
            content: attr(placeholder);
            color: #718096;
            pointer-events: none;
            display: block;
        }
        
        /* Spezielle Regel für Link-Färbung im Editor */
        #note-editor a {
            color: #3b82f6; /* Tailwind blue-500 */
            text-decoration: underline;
        }
        
        /* --- STABILISIERTE LISTE-STYLES --- */
        #note-editor ul, #note-editor ol, .note-card ul, .note-card ol {
            margin: 0; 
            padding-left: 1.5rem; 
        }
        
        #note-editor li, .note-card li {
            color: #ffffff !important;
        }

        #note-editor li::marker, .note-card li::marker {
            color: #ffffff !important;
        }
        
        /* Wichtig für List-Style-Type */
        /* Diese Regeln stellen sicher, dass die manuell gesetzten Stile angezeigt werden */
        #note-editor ul[style*="list-style-type: circle"], .note-card ul[style*="list-style-type: circle"] {
            list-style-type: circle !important;
        }
        #note-editor ul[style*="list-style-type: disc"], .note-card ul[style*="list-style-type: disc"] {
            list-style-type: disc !important;
        }
    </style>
</head>
<body class="bg-black min-h-screen p-4 flex items-center justify-center">

    <div class="bg-gray-900 p-6 rounded-3xl shadow-2xl w-full max-w-4xl transition-all duration-300 transform scale-100">
        <header class="mb-6 border-b pb-4 border-gray-700">
            <h1 class="text-4xl font-extrabold text-gray-100 text-center">
                Meine Offline-Notizen
            </h1>
        </header>

        <div class="mb-6 p-4 bg-gray-800 rounded-2xl shadow-inner">
            <h2 class="text-2xl font-bold text-gray-200 mb-4">Neue Notiz erstellen</h2>
            
            <input type="text" id="note-title-input" placeholder="Titel der Notiz (optional)" class="w-full p-3 mb-4 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
  
          
            <div class="flex flex-wrap gap-2 mb-4 p-2 bg-gray-700 rounded-xl">
                <button id="bold-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 font-bold">B</button>
                <button id="italic-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 italic">I</button>
                <button id="underline-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 underline">U</button>
                
    
                <div class="relative inline-block">
                    <button id="list-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Aufzählung
                    </button>
             
                    <div id="list-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="decimal">Nummerierung</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="disc">Punkte</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="circle">Kreise</button>
                    </div>
                </div>

                <div class="relative inline-block">
                    <button id="size-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Schriftgröße
                    </button>
                    <div id="size-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="1">Klein</button>
              
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="3">Mittel</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="5">Groß</button>
                    </div>
                </div>

              
                <div class="relative inline-block">
                    <button id="color-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Schriftfarbe
                    </button>
                    <div id="color-dropdown-menu" class="dropdown-menu">
 
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-white" data-value="white">Weiß</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-red-500" data-value="red">Rot</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-green-500" data-value="green">Grün</button>
  
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-blue-500" data-value="blue">Blau</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-yellow-500" data-value="yellow">Gelb</button>
                    </div>
                
                </div>

                <button id="link-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Link
                </button>

                <button id="indent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Einrücken
                </button>
                <button id="outdent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Ausrücken
                </button>
            </div>
     
        
          
            <div id="note-editor" class="w-full rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none transition-all duration-300" contenteditable="true" placeholder="Schreiben Sie hier Ihre neue Notiz..."></div>
            
            <div class="mt-4 flex justify-end space-x-2">
                <button id="save-note-btn" class="calculator-btn text-white font-medium py-2 px-5 
rounded-full shadow-lg transform">
                    Notiz speichern
                </button>
            </div>
    
        </div>
        
        <div class="mb-6 flex flex-col md:flex-row gap-4">
            <input type="text" id="search-input" placeholder="Notizen durchsuchen..." class="w-full md:w-1/3 p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            
            <div class="flex flex-col sm:flex-row gap-4 w-full md:w-2/3">
                
                <div class="relative w-full sm:w-1/2">
                    <button 
                        id="sort-dropdown-btn" 
                        class="calculator-btn w-full p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 text-left">
                        Sortieren nach: Unsortiert
                    </button>
                    <div id="sort-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg active" data-value="unsorted">Unsortiert</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="newest">Datum (neueste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="oldest">Datum (älteste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-asc">Titel (A-Z)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-desc">Titel (Z-A)</button>
                    </div>
                </div>

                <div class="flex gap-2 w-full sm:w-1/2">
                    <button id="export-btn" class="calculator-btn w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium">
                        Export 💾
                    </button>
                    <label for="import-file-input" 
                        class="w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium cursor-pointer text-center flex items-center justify-center">
                        Import 📥
                    </label>
                    <input type="file" id="import-file-input" accept="application/json" style="display: none;">
                </div>
            </div>
        </div>


        <div id="notes-list" class="space-y-4">
        </div>

        <div id="loading-indicator" class="text-center 
text-gray-400 mt-8 hidden">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
            <p class="mt-2">Notizen werden geladen...</p>
        </div>

        <div id="no-notes-message" class="text-center text-gray-400 mt-8 hidden">
            <p>Sie haben noch keine Notizen.
Fügen Sie eine neue hinzu, um zu beginnen!</p>
        </div>
    </div>

    <div id="modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-sm w-full">
            <p id="modal-text" class="text-lg font-semibold text-gray-200 text-center mb-4"></p>
            <div class="flex justify-center space-x-4">
                <button id="modal-confirm-btn" class="calculator-btn text-white 
font-medium py-2 px-5 rounded-full">
                    OK
                </button>
                <button id="modal-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full hidden">
                    Abbrechen
           
                </button>
            </div>
        </div>
    </div>

    <div id="link-modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-lg w-full">
            <h3 class="text-xl font-bold text-gray-200 mb-4 text-center">Link einfügen</h3>
            
            <p 
class="text-gray-300 mb-4 text-center">Geben Sie die URL für den Link ein.</p>
            <input type="text" id="link-url-input" placeholder="https://beispiel.de" class="w-full p-3 rounded-xl border border-gray-600 bg-gray-900 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            <div class="mt-6 flex justify-end space-x-4">
                <button id="link-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full">
                    Abbrechen
 
                </button>
                <button id="link-insert-btn" class="calculator-btn text-white font-medium py-2 px-5 rounded-full">
                    Einfügen
                </button>
            </div>
        </div>
   
    </div>

    <script>
        // DOM-Elemente
        const notesList = document.getElementById('notes-list');
        const noteTitleInput = document.getElementById('note-title-input');
        const noteEditor = document.getElementById('note-editor');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const searchInput = document.getElementById('search-input');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noNotesMessage = document.getElementById('no-notes-message');

        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const indentBtn = document.getElementById('indent-btn');
        const outdentBtn = document.getElementById('outdent-btn');
        const linkBtn = document.getElementById('link-btn');
        const listDropdownMenu = document.getElementById('list-dropdown-menu');
        const listDropdownBtn = document.getElementById('list-dropdown-btn');
        const listDropdownItems = listDropdownMenu.querySelectorAll('.dropdown-item');
        const sizeDropdownMenu = document.getElementById('size-dropdown-menu');
        const sizeDropdownBtn = document.getElementById('size-dropdown-btn');
        const sizeDropdownItems = sizeDropdownMenu.querySelectorAll('.dropdown-item');

        const colorDropdownMenu = document.getElementById('color-dropdown-menu');
        const colorDropdownBtn = document.getElementById('color-dropdown-btn');
        const colorDropdownItems = colorDropdownMenu.querySelectorAll('.dropdown-item');

        // Sortier-Elemente
        const sortDropdownBtn = document.getElementById('sort-dropdown-btn');
        const sortDropdownMenu = document.getElementById('sort-dropdown-menu');
        const sortDropdownItems = sortDropdownMenu.querySelectorAll('.dropdown-item');
        
        // KONSTANTEN FÜR IMPORT/EXPORT
        const exportBtn = document.getElementById('export-btn');
        const importFileInput = document.getElementById('import-file-input');
        
        // Modal-Elemente
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        // Link-Modal-Elemente
        const linkModalBackdrop = document.getElementById('link-modal-backdrop');
        const linkUrlInput = document.getElementById('link-url-input');
        const linkInsertBtn = document.getElementById('link-insert-btn');
        const linkCancelBtn = document.getElementById('link-cancel-btn');

        let notesData = [];
        let editingNoteId = null;
        let savedRange;
        // Zum Speichern der Auswahl
        let currentSortMethod = 'unsorted';
        // Speicherschlüssel als Konstante definieren
        const NOTES_STORAGE_KEY = 'notes';
        const colorMap = {
            'red': '#ff0000',
            'green': '#008000',
            'blue': '#3b82f6', // Etwas helleres Blau, das gut auf dem dunklen Hintergrund sichtbar ist
            'yellow': '#ffff00',
            'white': '#ffffff'
        };
        const sizeMap = {
            '1': 'Klein',
            '3': 'Mittel',
            '5': 'Groß'
        };
        // Drag-and-Drop-Variablen
        let draggedItem = null;
        
        // ******************************************************
        // ** HELPER FUNKTIONEN **
        // ******************************************************
        
        /**
         * Konvertiert einen RGB-Farbstring in einen Hex-String.
         */
        const rgbToHex = (rgb) => {
            const matches = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!matches) return rgb; 

            const hex = (x) => ("0" + parseInt(x).toString(16)).slice(-2);
            return "#" + hex(matches[1]) + hex(matches[2]) + hex(matches[3]);
        };


        // ******************************************************
        // ** MODAL LOGIK **
        // ******************************************************
        const showModal = (message, showCancelButton = false) => {
            return new Promise(resolve => {
                modalText.textContent = message;
                modalCancelBtn.style.display = showCancelButton ? 'inline-block' : 'none';
                modalBackdrop.classList.remove('hidden');
            
        
                const confirmHandler = () => {
                    modalBackdrop.classList.add('hidden');
                    resolve(true);
                };
                const cancelHandler = () => {
          
        
                    modalBackdrop.classList.add('hidden');
                    resolve(false);
                };
                modalConfirmBtn.onclick = confirmHandler;
                modalCancelBtn.onclick = cancelHandler;
    
            });
        };

        const showLinkModal = () => {
            return new Promise(resolve => {
                linkUrlInput.value = '';
                linkModalBackdrop.classList.remove('hidden');
                
                const insertHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(linkUrlInput.value);
                };
                const cancelHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(null);
                };
                // Einmalige Event Listener, um Konflikte zu vermeiden
                linkInsertBtn.onclick = insertHandler;
                linkCancelBtn.onclick = cancelHandler;
                
                // Fokus auf das Eingabefeld, sobald das Modal geöffnet wird
                linkUrlInput.focus();
            });
        };
        
        
        // ******************************************************
        // ** SELECTION/FOCUS LOGIK (WICHTIG für Toolbar) **
        // ******************************************************
        const getSelectionRange = () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                return selection.getRangeAt(0);
            }
            return null;
        };

        const saveSelection = () => {
            savedRange = getSelectionRange();
        };

        const restoreSelection = () => {
            if (savedRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedRange);
            }
        };
        
        /**
         * Führt einen Formatierungsbefehl aus und stellt den Fokus in den Editor zurück.
         * FIX 2 & 3: Entfernung der fehlerhaften ZWNB-Logik für B/I/U.
         * @param {string} command - Der execCommand-Befehl.
         * @param {string} value - Der Wert für den execCommand-Befehl.
         */
        const executeFormatAndRestore = (command, value = null) => {
            // 1. Auswahl wiederherstellen
            restoreSelection();
            // 2. Fokus setzen (wichtig für Android/Mobile)
            noteEditor.focus(); 
            
            // 3. Befehl ausführen (Für B/I/U wird hier der Schreib-Modus getoggelt)
            document.execCommand(command, false, value);

            // 4. Auswahl erneut speichern (nach der Ausführung)
            saveSelection();
            
            // 5. Toolbar-Status aktualisieren
            updateToolbarState();
        };

        
        const executeLinkCommand = async () => {
            // 1. Auswahl speichern
            saveSelection(); 
            
            // 2. Modal anzeigen und auf URL warten
            const url = await showLinkModal();
            
            // 3. Auswahl wiederherstellen 
            restoreSelection(); 
            
            if (url) {
                // Führt den Link-Befehl aus und ersetzt die aktuelle Auswahl
                document.execCommand('createLink', false, url);
                
                // Manuelle Korrektur für target="_blank"
                const selection = window.getSelection();
                const node = selection.anchorNode;
                
                // Versuche, das umgebende A-Tag zu finden
                let linkElement = node.nodeType === Node.TEXT_NODE ? node.parentNode : node;
                while (linkElement && linkElement !== noteEditor && linkElement.tagName !== 'A') {
                    linkElement = linkElement.parentNode;
                }
                
                if (linkElement && linkElement.tagName === 'A') {
                    linkElement.setAttribute('target', '_blank');
                }
            }
            
            // 4. Fokus in den Editor zurücksetzen
            noteEditor.focus(); 
            updateToolbarState(); 
        };
        
        // ******************************************************
        // ** LISTE (AUFZÄHLUNG) LOGIK **
        // ******************************************************
        
        /**
         * FIX 2: Vereinfachte und stabilere Listenfunktion.
         */
        const toggleList = (targetStyle) => {
            restoreSelection();
            noteEditor.focus();

            const isOrdered = targetStyle === 'decimal';
            const command = isOrdered ? 'insertOrderedList' : 'insertUnorderedList';

            // 1. Führe den execCommand aus (erstellt die Liste oder toggelt sie)
            document.execCommand(command, false, null);

            // 2. Suche das umgebende Listen-Element (UL oder OL)
            const selection = window.getSelection();
            // Verwenden Sie range.startContainer, um den Startpunkt der Auswahl zu erhalten.
            let node = selection.rangeCount > 0 ? selection.getRangeAt(0).startContainer : null;
            if (node && node.nodeType === Node.TEXT_NODE) node = node.parentNode;
            
            let list = node ? node.closest('UL, OL') : null;

            if (list && list.tagName === 'UL') {
                // 3. Wenn es eine UL ist, setze den spezifischen Stil (disc oder circle)
                list.style.listStyleType = targetStyle;
            }

            saveSelection();
            updateToolbarState();
        };
        
        /**
         * Helferfunktion: Findet das nächste Block-Level-Element (p, div, li, hx)
         * in Bezug auf den aktuellen Cursor innerhalb des noteEditor.
         */
        const getCurrentBlockElement = (selection) => {
            if (!selection.rangeCount) return null;

            let node = selection.getRangeAt(0).startContainer;
            
            if (node.nodeType === Node.TEXT_NODE) {
                node = node.parentNode;
            }

            while (node && node !== noteEditor) {
                const tagName = node.tagName;
                
                if (['P', 'DIV', 'LI', 'H1', 'H2', 'H3', 'UL', 'OL'].includes(tagName)) {
                    return node;
                }
                node = node.parentNode;
            }

            return noteEditor;
        };
        
        // ******************************************************
        // ** TOOLBAR AKTUALISIERUNG (ACTIVE MARKER) LOGIK **
        // ******************************************************
        
        const updateToolbarState = () => {
            const selection = window.getSelection();
            
            // FÜR FOKUS/CURSOR RÜCKKEHR: Speichere die Auswahl bei MouseUp oder KeyUp
            if (document.activeElement === noteEditor) {
                 saveSelection();
            }

            if (selection.rangeCount === 0 || !noteEditor.contains(selection.anchorNode)) {
                // Alle Buttons/Dropdowns de-aktivieren, wenn der Fokus nicht im Editor ist
                document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
                
                // Reset Dropdown Button Text
                listDropdownBtn.textContent = 'Aufzählung';
                sizeDropdownBtn.textContent = 'Schriftgröße';
                colorDropdownBtn.textContent = 'Schriftfarbe';
                return;
            }
            
            // Text-Formate (B/I/U)
            boldBtn.classList.toggle('active', document.queryCommandState('bold'));
            italicBtn.classList.toggle('active', document.queryCommandState('italic'));
            underlineBtn.classList.toggle('active', document.queryCommandState('underline'));
            linkBtn.classList.toggle('active', document.queryCommandState('createLink'));
            
            // 1. Listen-Formate (Dropdown Active Marker FIX)
            listDropdownItems.forEach(item => item.classList.remove('active'));
            const currentBlock = getCurrentBlockElement(selection);
            
            if (currentBlock) {
                let parentList = currentBlock.closest('UL, OL'); // Finde die Liste, selbst wenn LI ausgewählt ist
                
                if (parentList) {
                    let activeListStyle = 'disc'; // Default for UL
                    
                    if (parentList.tagName === 'OL') {
                        activeListStyle = parentList.style.listStyleType || 'decimal'; // 'decimal' als Fallback
                    } else if (parentList.tagName === 'UL') {
                        // Liest den manuell gesetzten Stil aus
                        activeListStyle = parentList.style.listStyleType || 'disc';
                        // Korrigiere für den Fall, dass style-type leer ist, aber der Browser disc verwendet (z.B. nach execCommand)
                        if (parentList.style.listStyleType === '' || parentList.style.listStyleType === 'unset') {
                            activeListStyle = 'disc'; 
                        }
                    }

                    const activeItem = Array.from(listDropdownItems).find(item => item.dataset.value === activeListStyle);
                    
                    if (activeItem) {
                        activeItem.classList.add('active');
                    } 
                } 
            }
            listDropdownBtn.textContent = 'Aufzählung'; 
            
            // 2. Schriftgröße (Dropdown Active Marker FIX)
            sizeDropdownItems.forEach(item => item.classList.remove('active'));
            // queryCommandValue gibt die numerische Größe (1-7) zurück
            let currentSize = document.queryCommandValue('fontSize');
            if (currentSize) {
                const activeItem = Array.from(sizeDropdownItems).find(item => item.dataset.value === currentSize);
                if (activeItem) {
                    activeItem.classList.add('active');
                } 
            } 
            sizeDropdownBtn.textContent = 'Schriftgröße'; 


            // 3. Schriftfarbe (Dropdown Active Marker FIX)
            colorDropdownItems.forEach(item => item.classList.remove('active'));
            let currentColor = document.queryCommandValue('foreColor');
            
            if (currentColor) {
                // Farbe in Hex konvertieren, falls RGB
                if (currentColor.startsWith('rgb')) {
                    currentColor = rgbToHex(currentColor);
                }
                
                // Finde den passenden Key in colorMap
                const colorKey = Object.keys(colorMap).find(key => colorMap[key].toLowerCase() === currentColor.toLowerCase());

                if (colorKey) {
                    const activeItem = Array.from(colorDropdownItems).find(item => item.dataset.value === colorKey);
                    if (activeItem) {
                        activeItem.classList.add('active');
                    } 
                } 
            }
            colorDropdownBtn.textContent = 'Schriftfarbe'; 
        };


        // ******************************************************
        // ** STORAGE UND RENDERING LOGIK **
        // ******************************************************
        
        const saveNotesToLocal = () => {
            try {
                // Nur die Reihenfolge in der unsortierten Ansicht speichern
                if (currentSortMethod === 'unsorted') {
                     const unsortedOrder = notesData.map(note => note.id);
                     localStorage.setItem('notes-order', JSON.stringify(unsortedOrder));
                }
                localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notesData));
            } catch (e) {
                console.error("Fehler beim Speichern der Notizen im lokalen Speicher:", e);
                showModal("Ihre Notizen konnten nicht gespeichert werden. Der lokale Speicher ist möglicherweise voll.");
            }
        };

        
        const loadNotesFromLocal = () => {
            try {
                const storedNotes = localStorage.getItem(NOTES_STORAGE_KEY);
                notesData = storedNotes ? JSON.parse(storedNotes) : [];
                
                // Lade die gespeicherte Reihenfolge für 'unsorted'
                const storedOrder = localStorage.getItem('notes-order');
                if (storedOrder && storedOrder.length > 0) {
                     const orderArray = JSON.parse(storedOrder);
                     // Sortiere notesData basierend auf der gespeicherten ID-Liste
                     notesData.sort((a, b) => {
                         const indexA = orderArray.indexOf(a.id);
                         const indexB = orderArray.indexOf(b.id);
                         if (indexA === -1 || indexB === -1) {
                             // Neue Notizen ans Ende
                             return a.id - b.id; 
                         }
                         return indexA - indexB;
                     });
                } else {
                     // Fallback: Neueste zuerst nach ID (dem ursprünglichen Standard)
                     notesData.sort((a, b) => b.id - a.id);
                }
                
                sortNotes(currentSortMethod, true); // Stellt die Sortierung ein und rendert
            } catch (e) {
                console.error("Fehler beim Laden der Notizen aus dem lokalen Speicher:", e);
                notesData = [];
                showModal("Ihre Notizen konnten nicht geladen werden. Möglicherweise ist die Datenstruktur beschädigt.");
                renderNotes();
            }
        };

        const renderNotes = (searchQuery = '') => {
            const fragment = document.createDocumentFragment();
            notesList.innerHTML = ''; 
            
            if (notesData.length === 0) {
                noNotesMessage.classList.remove('hidden');
                return;
            }
            noNotesMessage.classList.add('hidden');
            
            const filteredNotes = notesData.filter(note => {
                const searchLower = searchQuery.toLowerCase();
                const contentLower = note.content.toLowerCase();
                const titleLower = note.title ? note.title.toLowerCase() : '';
                
                return contentLower.includes(searchLower) || titleLower.includes(searchLower);
            });
            
            if (filteredNotes.length === 0 && searchQuery) {
                notesList.innerHTML = `<p class="text-center text-gray-400 mt-4">Keine Notizen gefunden für "${searchQuery}".</p>`;
                return;
            }
            
            filteredNotes.forEach(note => {
                fragment.appendChild(createNoteElement(note));
            });
            notesList.appendChild(fragment);
        };
        
        const createNoteElement = (note) => {
            const div = document.createElement('div');
            div.className = 'note-card p-4 rounded-xl shadow-lg border hover:shadow-2xl transition-all duration-300 transform hover:scale-[1.01] flex flex-col cursor-grab';
            div.draggable = currentSortMethod === 'unsorted'; 
            div.dataset.noteId = note.id; 

            const header = document.createElement('div');
            header.className = 'flex justify-between items-start mb-2';
            
            const title = document.createElement('h3');
            title.className = 'text-xl font-semibold text-gray-100 flex-grow pr-4';

            const hasTitle = note.title.trim() !== '';

            // Titel-Logik: Wenn Titel leer, zeige Anfang des Contents als Titel
            if (!hasTitle && note.content.trim() !== '') {
                 // Entferne HTML-Tags, um den Anfang des Textes zu bekommen
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content;
                const plainText = tempDiv.textContent || tempDiv.innerText || '';
                
                title.textContent = plainText.substring(0, 100) + (plainText.length > 100 ? '...' : '');
                title.classList.add('italic', 'text-gray-400');
            } else {
                title.textContent = note.title || 'Ohne Titel';
                title.classList.remove('italic', 'text-gray-400');
            }

            header.appendChild(title);

            const btnContainer = document.createElement('div');
            btnContainer.className = 'flex-shrink-0 flex space-x-2';
            
            const editBtn = document.createElement('button');
            editBtn.className = 'calculator-btn bg-blue-600 text-white p-2 rounded-full text-sm hover:bg-blue-700 transition-colors edit-btn';
            editBtn.innerHTML = '✏️';
            btnContainer.appendChild(editBtn);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'calculator-btn bg-red-600 text-white p-2 rounded-full text-sm hover:bg-red-700 transition-colors delete-btn';
            deleteBtn.innerHTML = '🗑️';
            btnContainer.appendChild(deleteBtn);

            header.appendChild(btnContainer);
            div.appendChild(header);

            // LOGIK: Content nur anzeigen, wenn KEIN Titel vorhanden ist
            if (!hasTitle && note.content.trim() !== '') {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'text-gray-300 note-content mt-2';
                contentDiv.innerHTML = note.content;
                div.appendChild(contentDiv);
            }
            
             editBtn.addEventListener('click', () => editNote(note.id, note.title, note.content));
             deleteBtn.addEventListener('click', () => deleteNote(note.id));
             
             if (currentSortMethod === 'unsorted') {
                 div.addEventListener('dragstart', handleDragStart);
                 div.addEventListener('dragover', handleDragOver);
                 div.addEventListener('drop', handleDrop);
                 div.addEventListener('dragend', handleDragEnd);
             }
             return div;
         };


        const saveNote = () => {
            const title = noteTitleInput.value.trim();
            const content = noteEditor.innerHTML.trim();

            if (!title && !content) {
                showModal("Bitte geben Sie einen Titel oder Inhalt für Ihre Notiz ein.");
                return;
            }

            const now = new Date().toISOString();

            if (editingNoteId !== null) {
                const noteIndex = notesData.findIndex(note => note.id === editingNoteId);
                if (noteIndex !== -1) {
                    notesData[noteIndex].title = title;
                    notesData[noteIndex].content = content;
                    notesData[noteIndex].updatedAt = now;
                }
                editingNoteId = null;
                saveNoteBtn.textContent = 'Notiz speichern';
                showModal("Notiz erfolgreich aktualisiert!");
            } else {
                const newNote = {
                    id: Date.now(),
                    title: title,
                    content: content,
                    createdAt: now,
                    updatedAt: now,
                };
                notesData.unshift(newNote);
                showModal("Notiz erfolgreich gespeichert!");
            }

            noteTitleInput.value = '';
            noteEditor.innerHTML = '';
            
            updateToolbarState();

            saveNotesToLocal();
            // FIX: Notizen sofort neu rendern nach dem Speichern
            sortNotes(currentSortMethod, true); 
        };
        
        const deleteNote = async (id) => {
            const confirm = await showModal("Möchten Sie diese Notiz wirklich löschen?", true);
            if (confirm) {
                notesData = notesData.filter(note => note.id !== id);
                saveNotesToLocal();
                renderNotes();
                showModal("Notiz gelöscht.");
            }
        };

        const editNote = (id, title, content) => {
            editingNoteId = id;
            noteTitleInput.value = title;
            noteEditor.innerHTML = content;
            saveNoteBtn.textContent = 'Änderungen speichern';
            window.scrollTo({ top: 0, behavior: 'smooth' }); 
            noteEditor.focus();
            
            // Auswahl ans Ende des Editors setzen
            const range = document.createRange();
            range.selectNodeContents(noteEditor);
            range.collapse(false);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            saveSelection(); 
            updateToolbarState();
        };

        // --- SORTIERFUNKTIONEN ---

        const sortNotes = (method, shouldRender = true) => {
            currentSortMethod = method;
            const sortMethodTextElement = Array.from(sortDropdownItems).find(item => item.dataset.value === method);
            const sortMethodText = sortMethodTextElement ? sortMethodTextElement.textContent : 'Unsortiert';
            sortDropdownBtn.textContent = `Sortieren nach: ${sortMethodText}`;

            sortDropdownItems.forEach(item => item.classList.remove('active'));
            if (sortMethodTextElement) {
                sortMethodTextElement.classList.add('active');
            }

            switch (method) {
                case 'newest':
                    notesData.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    break;
                case 'oldest':
                    notesData.sort((a, b) => new Date(a.updatedAt) - new Date(b.updatedAt));
                    break;
                case 'title-asc':
                    notesData.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                    break;
                case 'title-desc':
                    notesData.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
                    break;
                case 'unsorted':
                default:
                    // Wenn unsortiert, wird die Reihenfolge in loadNotesFromLocal oder manuell festgelegt (dank Drag&Drop)
                    // Hier ist keine Sortierung nötig, da die Reihenfolge im Array durch Drag&Drop oder Load definiert ist
                    break;
            }

            if (method === 'unsorted') {
                saveNotesToLocal(); // Speichert die aktuelle Reihenfolge
            }

            if (shouldRender) {
                renderNotes(searchInput.value);
            }
        };

        // --- IMPORT/EXPORT FUNKTIONEN ---
        const exportNotes = async () => { 
            const notesJson = localStorage.getItem(NOTES_STORAGE_KEY);
            if (!notesJson || notesJson === '[]') {
                await showModal('Keine Notizen zum Exportieren vorhanden.', false);
                return;
            }

            const blob = new Blob([notesJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            a.href = url;
            a.download = `Meine_Offline_Notizen_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        const importNotes = (event) => {
             const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedNotes = JSON.parse(e.target.result);
                    if (Array.isArray(importedNotes)) {
                        
                        // Stelle sicher, dass jede importierte Notiz eine eindeutige ID bekommt, um Konflikte zu vermeiden
                        const maxId = notesData.reduce((max, note) => Math.max(max, note.id), 0);
                        let nextId = maxId + 1;
                        
                        const notesToAdd = importedNotes.map(note => ({
                            ...note,
                            id: nextId++,
                            createdAt: note.createdAt || new Date().toISOString(),
                            updatedAt: new Date().toISOString()
                        }));

                        notesData = notesData.concat(notesToAdd);
                        
                        saveNotesToLocal();
                        loadNotesFromLocal(); // Lädt und rendert neu
                        await showModal('Notizen erfolgreich importiert und geladen!', false);
                    } else {
                        await showModal('Fehler: Die importierte Datei hat kein gültiges Notizformat.', false);
                    }
                } catch (error) {
                    await showModal('Fehler beim Lesen oder Parsen der Datei.', false);
                    console.error('Import error:', error);
                }
                event.target.value = null; 
            };
            reader.onerror = () => {
                showModal('Fehler beim Lesen der Datei.', false);
            };
            reader.readAsText(file);
        };
        // --- ENDE IMPORT/EXPORT FUNKTIONEN ---

        // --- DRAG AND DROP ---
        
        let dragSrcEl = null;

        const handleDragStart = (e) => {
            if (currentSortMethod !== 'unsorted') {
                e.preventDefault();
                return;
            }
            dragSrcEl = e.currentTarget;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.noteId); 
            e.currentTarget.classList.add('dragging');
        };

        const handleDragOver = (e) => {
            if (currentSortMethod !== 'unsorted') return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        };

        const handleDrop = (e) => {
            if (currentSortMethod !== 'unsorted') return;
            e.stopPropagation();

            const targetEl = e.currentTarget;

            if (dragSrcEl !== targetEl) {
                const listArray = Array.from(notesList.children);
                
                const dragIndex = listArray.indexOf(dragSrcEl);
                const dropIndex = listArray.indexOf(targetEl);

                // Datenmodell aktualisieren
                const [draggedNote] = notesData.splice(dragIndex, 1);
                notesData.splice(dropIndex, 0, draggedNote);
                
                // DOM aktualisieren
                if (dragIndex < dropIndex) {
                    notesList.insertBefore(dragSrcEl, targetEl.nextSibling);
                } else {
                    notesList.insertBefore(dragSrcEl, targetEl);
                }

                saveNotesToLocal();
            }
        };

        const handleDragEnd = (e) => {
            if (currentSortMethod !== 'unsorted') return;
            e.currentTarget.classList.remove('dragging');
        };


        // --- EVENT LISTENERS ---

        // Event Listener für die Toolbar-Buttons (mit Fokus-Wiederherstellung)
        // Wichtig: Speichern der Auswahl bei Interaktion im Editor
        noteEditor.addEventListener('mouseup', saveSelection); 
        noteEditor.addEventListener('keyup', updateToolbarState); 
        
        // Stellt sicher, dass die Auswahl gespeichert wird, bevor der Button gedrückt wird (für Touch/Click)
        document.querySelectorAll('.calculator-btn').forEach(btn => {
             // Wichtig: Mousedown event feuert vor dem Blur/Click-Verlust
            btn.addEventListener('mousedown', saveSelection);
        });

        // WICHTIG: Alle Formatierungs- und Einrückbefehle verwenden nun die vereinfachte, robuste executeFormatAndRestore
        boldBtn.addEventListener('click', () => executeFormatAndRestore('bold'));
        italicBtn.addEventListener('click', () => executeFormatAndRestore('italic'));
        underlineBtn.addEventListener('click', () => executeFormatAndRestore('underline'));
        indentBtn.addEventListener('click', () => executeFormatAndRestore('indent'));
        outdentBtn.addEventListener('click', () => executeFormatAndRestore('outdent'));
        linkBtn.addEventListener('click', executeLinkCommand);

        listDropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            saveSelection(); 
            listDropdownMenu.classList.toggle('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        listDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleList(item.dataset.value); // Neue, stabilere Listenfunktion
            listDropdownMenu.classList.remove('active');
        }));
        
        sizeDropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            saveSelection(); 
            sizeDropdownMenu.classList.toggle('active');
            listDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        sizeDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            executeFormatAndRestore('fontSize', item.dataset.value); 
            sizeDropdownMenu.classList.remove('active');
        }));

        colorDropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            saveSelection(); 
            colorDropdownMenu.classList.toggle('active');
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        colorDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorName = item.dataset.value;
            const hexColor = colorMap[colorName];
            executeFormatAndRestore('foreColor', hexColor); // Schriftfarbe
            colorDropdownMenu.classList.remove('active');
        }));

        // Sortier-Events
        sortDropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sortDropdownMenu.classList.toggle('active');
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
        });
        sortDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            sortNotes(item.dataset.value);
            sortDropdownMenu.classList.remove('active');
        }));

        // Globale Klick-Events zum Schließen von Dropdowns
        document.addEventListener('click', () => {
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        
        // Speichern und Suchen
        saveNoteBtn.addEventListener('click', saveNote);
        searchInput.addEventListener('input', (e) => renderNotes(e.target.value));
        
        // Import/Export
        exportBtn.addEventListener('click', exportNotes);
        importFileInput.addEventListener('change', importNotes);
        
        // Event listener zur Aktualisierung des Toolbar-Zustands bei Fokuswechsel
        noteEditor.addEventListener('focus', updateToolbarState);
        noteEditor.addEventListener('blur', updateToolbarState);
        noteEditor.addEventListener('input', updateToolbarState);


        // Initial loading of notes
        window.addEventListener('load', loadNotesFromLocal);
    </script>
</body>
</html>
