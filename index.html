<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hybrider Drag & Drop Test</title>
    <style>
        /* ************************************** */
        /* CSS STYLES */
        /* ************************************** */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1f2937; /* Dunkler Hintergrund */
            color: #f3f4f6;
        }

        #notes-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 2px solid #374151;
            border-radius: 8px;
        }

        .note-card {
            padding: 15px;
            border-radius: 6px;
            background-color: #4b5563; /* Mittelgraue Karte */
            cursor: grab;
            transition: transform 0.2s, opacity 0.2s;
            
            /* WICHTIG für Touch: Erlaubt Dragging, aber verhindert Scrollen beim Halten */
            touch-action: none; 
        }

        .note-card:active {
            cursor: grabbing;
        }

        .note-card.dragging {
            opacity: 0.4;
            transform: scale(0.98);
        }

        /* Testbereich für Markieren */
        .note-content {
            margin-top: 5px;
            font-size: 0.9em;
            color: #d1d5db;
        }
    </style>
</head>
<body>

    <h1>Drag & Drop Test</h1>
    <p>Testen Sie D&D mit der Maus (PC) und Long Press (Mobil, z.B. Opera Android).</p>
    <p><strong>Ziel:</strong> Kurzes Halten sollte Markieren/Kontextmenü erlauben, langes Halten (Long Press) sollte Dragging starten.</p>

    <div id="notes-container">
        </div>

    <script>
        // **************************************
        // ** JAVASCRIPT LOGIC **
        // **************************************

        // Globale Variablen
        const notesList = document.getElementById('notes-container');
        let draggedItem = null;
        let touchTimeout = null;
        let isDragging = false;
        const DRAG_THRESHOLD = 5; // Pixel-Toleranz für Bewegung
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // Simuliere notesData für das Speichern
        let notesData = [
            { id: '1', title: 'Erste Notiz', content: 'Dies ist Notiz 1. Versuch hier, Text zu markieren.' },
            { id: '2', title: 'Zweite Notiz', content: 'Dies ist Notiz 2. Bei Long-Press hier, sollte Drag starten.' },
            { id: '3', title: 'Dritte Notiz', content: 'Dies ist Notiz 3. Wichtiges Element.' }
        ];

        // *** HILFSFUNKTIONEN ***
        const saveNotesToLocal = () => {
             console.log("Daten gespeichert. Neue Reihenfolge:", notesData.map(n => n.id));
             // Hier würde die eigentliche localStorage-Speicherung erfolgen.
        };

        const createNoteCard = (note) => {
            const card = document.createElement('div');
            card.className = 'note-card';
            card.dataset.id = note.id;
            card.innerHTML = `
                <b>${note.title}</b>
                <div class="note-content">${note.content}</div>
            `;
            return card;
        };

        const renderNotes = () => {
            notesList.innerHTML = '';
            notesData.forEach(note => {
                notesList.appendChild(createNoteCard(note));
            });
            setupDragAndDrop();
        };


        // ******************************************************
        // ** TOUCH-HANDLER FUNKTIONEN (für Touch-Geräte) **
        // ******************************************************

        function handleTouchStart(e) {
            // Wenn auf ein bearbeitbares Element (z.B. Inhalt) geklickt wird, Markieren zulassen und abbrechen
            if (e.target.closest('.note-content, .note-title') || e.touches.length !== 1) return; 

            const noteCard = this;
            draggedItem = noteCard;
            
            // Sofortige Blockierung des Markierens, um den Long-Press-Timer sauber zu starten
            noteCard.style.userSelect = 'none';
            noteCard.style.webkitUserSelect = 'none';

            noteCard.initialX = e.touches[0].clientX;
            noteCard.initialY = e.touches[0].clientY;
            
            // Starte den Long-Press Timeout
            touchTimeout = setTimeout(() => {
                isDragging = true;
                // Optional: Visuelles Feedback, dass Drag-Modus aktiv ist
                // noteCard.classList.add('ready-to-drag'); 
            }, 200); 

            // Listener hinzufügen
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
        }

        function handleTouchMove(e) {
            if (!draggedItem) return;
            
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const dx = Math.abs(currentX - draggedItem.initialX);
            const dy = Math.abs(currentY - draggedItem.initialY);

            // Bedingung 1: Abbruch des Long Press (Nutzer scrollt oder tippt schnell)
            if (touchTimeout && (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD)) {
                clearTimeout(touchTimeout);
                touchTimeout = null;
                
                // Gib die Markier-Kontrolle zurück und beende den Prozess
                draggedItem.style.userSelect = 'auto';
                draggedItem.style.webkitUserSelect = 'auto';
                
                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);
                draggedItem = null;
                return; 
            }
            
            // Bedingung 2: Drag-Modus ist aktiv (Long Press ist abgelaufen)
            if (isDragging) {
                e.preventDefault(); // Verhindert natives Verhalten (Markieren/Scrollen)
                
                if (!draggedItem.classList.contains('dragging')) {
                    draggedItem.classList.add('dragging');
                }
                
                // RE-ORDERING LOGIK (Emulation von dragover)
                const targetElement = document.elementFromPoint(currentX, currentY);
                const targetCard = targetElement ? targetElement.closest('.note-card') : null;

                if (targetCard && targetCard !== draggedItem) {
                    const bounding = targetCard.getBoundingClientRect();
                    const offset = bounding.y + (bounding.height / 2);
                    
                    if (currentY < offset) {
                        notesList.insertBefore(draggedItem, targetCard);
                    } else {
                        notesList.insertBefore(draggedItem, targetCard.nextElementSibling);
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (touchTimeout) {
                clearTimeout(touchTimeout);
                touchTimeout = null;
            }

            if (!draggedItem) return;

            // Speichere nur, wenn ein tatsächlicher Drag stattfand
            if (isDragging) {
                draggedItem.classList.remove('dragging');
                
                // Speicherlogik (Reihenfolge aktualisieren)
                const newOrder = Array.from(notesList.children).map(child => String(child.dataset.id));
                // Hier würden Sie notesData sortieren und speichern
                notesData.sort((a, b) => newOrder.indexOf(a.id) - newOrder.indexOf(b.id));
                saveNotesToLocal();
            }
            
            // Gib die Markier-Kontrolle zurück und räume auf
            draggedItem.style.userSelect = 'auto';
            draggedItem.style.webkitUserSelect = 'auto';
            
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            isDragging = false; 

            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }
        
        // ******************************************************
        // ** DRAG-AND-DROP SETUP FUNKTION (HYBRID) **
        // ******************************************************

        const setupDragAndDrop = () => {
            const noteCards = notesList.querySelectorAll('.note-card');

            noteCards.forEach(card => {
                
                // Setze das "draggable"-Attribut basierend auf dem Gerätetyp
                card.setAttribute('draggable', isTouchDevice ? 'false' : 'true');

                if (isTouchDevice) {
                    // *** TOUCH-LOGIK: Verwendet Long-Press Emulation ***
                    card.addEventListener('touchstart', handleTouchStart, { passive: false });
                    
                } else {
                    // *** MAUS-LOGIK: Verwendet native HTML5 D&D ***

                    card.addEventListener('dragstart', (e) => {
                        draggedItem = card;
                        e.dataTransfer.setData('text/plain', '');
                        setTimeout(() => card.classList.add('dragging'), 0);
                    });

                    card.addEventListener('dragend', () => {
                        setTimeout(() => {
                            draggedItem.classList.remove('dragging');
                            draggedItem = null;
                            
                            // Speicherlogik (Reihenfolge aktualisieren)
                            const newOrder = Array.from(notesList.children).map(child => String(child.dataset.id));
                            notesData.sort((a, b) => newOrder.indexOf(a.id) - newOrder.indexOf(b.id));
                            saveNotesToLocal();
                        }, 0);
                    });

                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (draggedItem && draggedItem !== card) {
                            const bounding = card.getBoundingClientRect();
                            const offset = bounding.y + (bounding.height / 2);

                            if (e.clientY < offset) {
                                notesList.insertBefore(draggedItem, card);
                            } else {
                                notesList.insertBefore(draggedItem, card.nextElementSibling);
                            }
                        }
                    });
                }
            });
        };

        // Starte die Anwendung
        document.addEventListener('DOMContentLoaded', renderNotes);
    </script>
</body>
</html>
