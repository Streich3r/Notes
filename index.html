<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meine Offline-Notizen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root{
            /* BASICS */
            --btn-gray: #4b5563;
 /* bg-gray-600 */
            --btn-blue: #2563eb;
 /* bg-blue-600 */
            --btn-green: #10b981;
 /* bg-green-600 */
            --btn-yellow: #fbbf24;
 /* bg-yellow-600 */
            --accent: #6aa1ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            -webkit-tap-highlight-color: transparent;
        }

        .note-card {
            background-color: #1a202c;
 border-color: #2d3748;
            cursor: grab;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .note-card.dragging {
            opacity: 0.5;
 transform: scale(0.95);
        }
        #note-editor {
            min-height: 100px;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid #4a5568; 
            background-color: #1a202c;
            color: #ffffff;
            outline: none; 
            transition: all 0.3s;
            overflow-x: hidden !important; /* 1. HINDERT DEN INHALT DARAN, HORIZONTAL HERAUSZURAGEN */
            white-space: pre-wrap;
            word-break: normal;
            overflow-wrap: break-word; /* Alternative/Erg√§nzung f√ºr besseren Support */
        }
        
        #note-editor:focus {
            outline: none !important;
        }

        /* ----------------------------------------------------- */
        /* --- RECHNER-PRINZIP CSS-REGELN F√úR ALLE BUTTONS --- */
        /* ----------------------------------------------------- */
        .calculator-btn, label[for="import-file-input"],
        #indent-btn,
        #outdent-btn
        {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: transform .06s ease, background-color 0.2s ease;
            border: none;
        }

     

        .calculator-btn:focus, label[for="import-file-input"]:focus {
            outline: none !important;
 box-shadow: none !important;
        }

        .calculator-btn:focus-visible, label[for="import-file-input"]:focus-visible {
            outline: 2px solid var(--accent);
 outline-offset: 2px;
        }
        
        /* Graue Buttons (Toolbar, Sort, Modal-Cancel) */
        .toolbar-btn, 
        .dropdown-item,
        #sort-dropdown-btn,
        #modal-cancel-btn, 
        #link-cancel-btn, 
        .note-action-btn,
        #indent-btn, /* F√ºgt den Einr√ºck-Button hier hinzu */
        #outdent-btn /* F√ºgt den Ausr√ºck-Button hier hinzu */
        {
            background-color: var(--btn-gray) !important;
        }
        
        .toolbar-btn:hover:not(.active),
        .dropdown-item:hover:not(.active),
        #sort-dropdown-btn:hover, 
        #modal-cancel-btn:hover, 
        #link-cancel-btn:hover, 
        .note-action-btn:hover,
        #indent-btn:hover, /* F√ºgt den Einr√ºck-Button hier hinzu */
        #outdent-btn:hover /* F√ºgt den Ausr√ºck-Button hier hinzu */
        {
            background-color: var(--btn-gray) !important;
        }
        
        .toolbar-btn:active, 
        .dropdown-item:active,
        #sort-dropdown-btn:active,
        #modal-cancel-btn:active,
        #link-cancel-btn:active, 
        #indent-btn:active, /* F√ºgt den Einr√ºck-Button hier hinzu */
        #outdent-btn:active, /* F√ºgt den Ausr√ºck-Button hier hinzu */
        .note-action-btn:active 
        {
             background-color: #374151 !important; /* bg-gray-700 */
             transform: scale(0.96); 
        }


        /* WICHTIG: Blauer Hintergrund f√ºr aktive Toolbar-Buttons und Dropdown-Elemente */
        .toolbar-btn.active, .dropdown-item.active {
            background-color: var(--btn-blue) !important;
 color: #ffffff !important;
        }

        /* Blaue Buttons (Save, Modal-Confirm, Link-Insert) */
        #save-note-btn, #modal-confirm-btn, #link-insert-btn {
            background-color: var(--btn-blue) !important;
        }
        #save-note-btn:hover, #modal-confirm-btn:hover, #link-insert-btn:hover {
            background-color: #1d4ed8 !important;
 /* bg-blue-700 */
        }
        #save-note-btn:active, #modal-confirm-btn:active, #link-insert-btn:active {
            background-color: #1e40af !important;
 /* bg-blue-800 */
        }

        /* Gr√ºne Buttons (Export) */
        #export-btn {
            background-color: var(--btn-green) !important;
        }
        #export-btn:hover {
            background-color: #059669 !important;
 /* bg-green-700 */
        }
        #export-btn:active {
            background-color: #047857 !important;
 /* bg-green-800 */
        }
        
        /* Gelbe Buttons (Import) */
        label[for="import-file-input"] {
            background-color: var(--btn-green) !important;
        }
        label[for="import-file-input"]:hover {
             background-color: #059669 !important;
 /* bg-yellow-600/700 */
        }
        label[for="import-file-input"]:active {
            background-color: #047857 !important;
 /* bg-yellow-800 */
        }
        
        /* Dropdown Men√º Styling */
        .dropdown-menu {
            position: absolute;
 z-index: 10;
            top: 100%;
            left: 0;
            margin-top: 0.5rem;
            background-color: #374151;
 /* bg-gray-700 */
            border-radius: 0.5rem;
            padding: 0.25rem;
 box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            width: max-content;
            min-width: 100%;
        }

        .dropdown-menu.active {
            display: flex;
        }

        #note-editor:empty:before {
            content: attr(placeholder);
 color: #718096;
            pointer-events: none;
            display: block;
        }
        
        /* Spezielle Regel f√ºr Link-F√§rbung im Editor */
        #note-editor a, 
        .note-card a  {
            color: #3b82f6 !important; 
 /* Tailwind blue-500 */
            text-decoration: underline !important; 
        }
        
        /* --- STABILISIERTE LISTE-STYLES --- */
        #note-editor ul, #note-editor ol, .note-card ul, .note-card ol {
            margin: 0;
 padding-left: 1.5rem; 
        }
        
        #note-editor li, .note-card li {
            color: #ffffff !important;
        }

        #note-editor li::marker, .note-card li::marker {
            color: #ffffff !important;
        }
        
        /* ERG√ÑNZUNG: Spezielle CSS-Regeln f√ºr die Listentypen (aus besser2.txt) */
        /* Kreise (Hohle Kreise) */
        #note-editor ul[style*="list-style-type: circle"], .note-card ul[style*="list-style-type: circle"] {
            list-style-type: circle !important;
        }
        
        /* Punkte (Gef√ºllte Scheiben/Discs) */
        #note-editor ul[style*="list-style-type: disc"], .note-card ul[style*="list-style-type: disc"] {
            list-style-type: disc !important;
        }
        
        /* Fallback f√ºr ul ohne Stil */
        #note-editor ul:not([style]), .note-card ul:not([style]) {
             list-style-type: disc !important;
        }
        
        #note-editor ol, .note-card ol {
            list-style-type: decimal;
        }
        
        /* Stil f√ºr die neuen Icon-Buttons */
        .note-action-btn {
            width: 38px;
            height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Entfernt internes Padding, da wir feste Gr√∂√üe haben */
            font-size: 1.25rem; /* F√ºr die Icons */
            border-radius: 9999px; /* Rund */
        }

        /* Dies ist der ABSOLUT LETZTE BLOCK im <style> Tag */
button#indent-btn:active, 
button#outdent-btn:active {
    /* Die gew√ºnschte Hintergrundfarbe wird hier gnadenlos erzwungen */
    background-color: #374151 !important; 
    
    /* Der Transform-Effekt wird auch hier explizit gesetzt, um Konflikte zu vermeiden */
    transform: scale(0.96); 
}
    </style>
</head>
<body class="bg-black min-h-screen p-4 flex items-center justify-center">

    <div class="bg-gray-900 p-6 rounded-3xl shadow-2xl w-full max-w-4xl transition-all duration-300 transform scale-100">
        
        <header class="mb-6 border-b pb-4 border-gray-700">
            <h1 class="text-4xl font-extrabold text-gray-100 text-center">
                Meine Offline-Notizen
            </h1>
        </header>

        <div class="mb-6 p-4 bg-gray-800 rounded-2xl shadow-inner">
            <h2 class="text-2xl font-bold text-gray-200 mb-4">Neue Notiz erstellen</h2>
            
            <input type="text" id="note-title-input" placeholder="Titel der Notiz (optional)" class="w-full p-3 mb-4 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
  
          
      
       <div class="flex flex-wrap gap-2 mb-4 p-2 bg-gray-700 rounded-xl">
                <button id="bold-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 font-bold">B</button>
                <button id="italic-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 italic">I</button>
                <button id="underline-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200 underline">U</button>
                
  
   
                <div class="relative inline-block">
                    <button id="list-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Aufz√§hlung
                    </button>
          
           
                    <div id="list-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="decimal">Nummerierung</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="disc">Punkte</button>
           
              <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="circle">Kreise</button>
                    </div>
                </div>

                <div class="relative inline-block">
                    <button id="size-dropdown-btn" class="calculator-btn toolbar-btn p-2 
 rounded-lg text-gray-200">
                        Schriftgr√∂√üe
                    </button>
                    <div id="size-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="1">Klein</button>
 
              
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="3">Mittel</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="5">Gro√ü</button>
                    </div>
   
                 </div>

              
                <div class="relative inline-block">
                    <button id="color-dropdown-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                        Schriftfarbe
     
                 </button>
                    <div id="color-dropdown-menu" class="dropdown-menu">
 
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-white" data-value="white">Wei√ü</button>
                        <button class="calculator-btn dropdown-item w-full text-left 
 px-4 py-2 rounded-lg text-red-500" data-value="red">Rot</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-green-500" data-value="green">Gr√ºn</button>
  
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg text-blue-500" data-value="blue">Blau</button>
                        <button class="calculator-btn dropdown-item w-full 
 text-left px-4 py-2 rounded-lg text-yellow-500" data-value="yellow">Gelb</button>
                    </div>
                
                </div>

                <button id="link-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Link
 
                </button>

                <button id="indent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
                    Einr√ºcken
                </button>
                <button id="outdent-btn" class="calculator-btn toolbar-btn p-2 rounded-lg text-gray-200">
     
                Ausr√ºcken
                </button>
            </div>
     
        
          
            <div id="note-editor" class="w-full rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none transition-all duration-300" contenteditable="true" placeholder="Schreiben Sie hier Ihre neue Notiz..."></div>
  
           
            <div class="mt-4 flex justify-end space-x-2">
                <button id="save-note-btn" class="calculator-btn text-white font-medium py-2 px-5 
rounded-full shadow-lg transform">
                    Notiz speichern
                </button>
            
 </div>
    
        </div>

        <div class="mb-6 flex 
 flex-col md:flex-row gap-4">
            <input type="text" id="search-input" placeholder="Notizen durchsuchen..." class="w-full md:w-1/3 p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            
            <div class="flex flex-col sm:flex-row gap-4 w-full md:w-2/3">
                
                <div class="relative w-full sm:w-1/2">
   
                  <button 
                        id="sort-dropdown-btn" 
                        class="calculator-btn w-full p-3 rounded-xl border border-gray-600 bg-gray-800 text-gray-100 text-left">
                        Sortieren 
 nach: Unsortiert
                    </button>
                    <div id="sort-dropdown-menu" class="dropdown-menu">
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg active" data-value="unsorted">Unsortiert</button>
                        
 <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="newest">Datum (neueste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="oldest">Datum (√§lteste zuerst)</button>
                        <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-asc">Titel (A-Z)</button>
                       
  <button class="calculator-btn dropdown-item w-full text-left px-4 py-2 rounded-lg" data-value="title-desc">Titel (Z-A)</button>
                    </div>
                </div>

                <div class="flex gap-2 w-full sm:w-1/2">
                    <button id="export-btn" class="calculator-btn w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium">
     
                    Export üíæ
                    </button>
                    <label for="import-file-input" 
                        class="w-1/2 p-3 rounded-xl border border-gray-600 text-white font-medium cursor-pointer text-center flex items-center justify-center">
   
                      Import üì•
                    </label>
                    <input type="file" id="import-file-input" accept="application/json" style="display: none;">
                </div>
            </div>
     
    </div>

        <div id="notes-list" class="space-y-4">
        </div>

        <div id="loading-indicator" class="text-center 
text-gray-400 mt-8 hidden">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
            <p class="mt-2">Notizen werden geladen...</p>
        </div>

        <div id="no-notes-message" class="text-center text-gray-400 mt-8 hidden">
 
            <p>Sie haben noch keine Notizen.
 F√ºgen Sie eine neue hinzu, um zu beginnen!</p>
        </div>
    </div>

    <div id="modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-sm w-full">
            <p id="modal-text" class="text-lg font-semibold text-gray-200 text-center mb-4"></p>
            <div class="flex justify-center space-x-4">
                <button id="modal-confirm-btn" class="calculator-btn text-white 
 
font-medium py-2 px-5 rounded-full">
                    OK
                </button>
                <button id="modal-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full hidden">
                    Abbrechen
           
      
           </button>
            </div>
        </div>
    </div>

    <div id="link-modal-backdrop" class="fixed inset-0 bg-gray-950 bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-lg w-full">
            <h3 class="text-xl font-bold text-gray-200 mb-4 text-center">Link einf√ºgen</h3>
            
        
     <p 
class="text-gray-300 mb-4 text-center">Geben Sie die URL f√ºr den Link ein.</p>
            <input type="text" id="link-url-input" placeholder="https://beispiel.de" class="w-full p-3 rounded-xl border border-gray-600 bg-gray-900 text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 focus:outline-none">
            <div class="mt-6 flex justify-end space-x-4">
                <button id="link-cancel-btn" class="calculator-btn text-gray-200 font-medium py-2 px-5 rounded-full">
                   
  Abbrechen
 
                </button>
                <button id="link-insert-btn" class="calculator-btn text-white font-medium py-2 px-5 rounded-full">
                    Einf√ºgen
                </button>
            </div>
        </div>
   
 
    </div>

    <script>
        // DOM-Elemente
        const notesList = document.getElementById('notes-list');
        const noteTitleInput = document.getElementById('note-title-input');
        const noteEditor = document.getElementById('note-editor');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const searchInput = document.getElementById('search-input');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noNotesMessage = document.getElementById('no-notes-message');

        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const indentBtn = document.getElementById('indent-btn');
        const outdentBtn = document.getElementById('outdent-btn');
        const linkBtn = document.getElementById('link-btn');

        const listDropdownMenu = document.getElementById('list-dropdown-menu');
        const listDropdownBtn = document.getElementById('list-dropdown-btn');
        const listDropdownItems = listDropdownMenu.querySelectorAll('.dropdown-item');

        const sizeDropdownMenu = document.getElementById('size-dropdown-menu');
        const sizeDropdownBtn = document.getElementById('size-dropdown-btn');
        const sizeDropdownItems = sizeDropdownMenu.querySelectorAll('.dropdown-item');

        const colorDropdownMenu = document.getElementById('color-dropdown-menu');
        const colorDropdownBtn = document.getElementById('color-dropdown-btn');
        const colorDropdownItems = colorDropdownMenu.querySelectorAll('.dropdown-item');

        // Sortier-Elemente
        const sortDropdownBtn = document.getElementById('sort-dropdown-btn');
        const sortDropdownMenu = document.getElementById('sort-dropdown-menu');
        const sortDropdownItems = sortDropdownMenu.querySelectorAll('.dropdown-item');

        // KONSTANTEN F√úR IMPORT/EXPORT
        const exportBtn = document.getElementById('export-btn');
        const importFileInput = document.getElementById('import-file-input');

        // Modal-Elemente
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        
        // Link-Modal-Elemente
        const linkModalBackdrop = document.getElementById('link-modal-backdrop');
        const linkUrlInput = document.getElementById('link-url-input');
        const linkInsertBtn = document.getElementById('link-insert-btn');
        const linkCancelBtn = document.getElementById('link-cancel-btn');

        let notesData = [];
        let editingNoteId = null;
        let savedRange; // Zum Speichern der Auswahl
        let currentSortMethod = 'unsorted';
        
        // Speicherschl√ºssel als Konstante definieren
        const NOTES_STORAGE_KEY = 'notes';

        const colorMap = {
            'red': '#ff0000',
            'green': '#008000',
            'blue': '#3b82f6', // Etwas helleres Blau, das gut auf dem dunklen Hintergrund sichtbar ist
            'yellow': '#ffff00',
            'white': '#ffffff'
        };

        const sizeMap = {
            '1': 'Klein',
            '3': 'Mittel',
            '5': 'Gro√ü'
        };

        // Drag-and-Drop-Variablen
        let draggedItem = null;

        // ******************************************************
        // ** HELPER FUNKTIONEN **
        // ******************************************************

        /**
         * Konvertiert einen RGB-Farbstring in einen Hex-String.
         * N√∂tig, da document.queryCommandValue('foreColor') oft RGB zur√ºckgibt.
         */
        const rgbToHex = (rgb) => {
            const matches = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!matches) return rgb; // Wenn keine RGB-Daten, gib den urspr√ºnglichen Wert zur√ºck
            const hex = (x) => ("0" + parseInt(x).toString(16)).slice(-2);
            return "#" + hex(matches[1]) + hex(matches[2]) + hex(matches[3]);
        };

        // ******************************************************
        // ** MODAL LOGIK **
        // ******************************************************

        const showModal = (message, showCancelButton = false) => {
            return new Promise(resolve => {
                modalText.textContent = message;
                modalCancelBtn.style.display = showCancelButton ? 'inline-block' : 'none';
                modalBackdrop.classList.remove('hidden');

                const confirmHandler = () => {
                    modalBackdrop.classList.add('hidden');
                    resolve(true);
                };

                const cancelHandler = () => {
                    modalBackdrop.classList.add('hidden');
                    resolve(false);
                };

                modalConfirmBtn.onclick = confirmHandler;
                modalCancelBtn.onclick = cancelHandler;
            });
        };

        const showLinkModal = () => {
            return new Promise(resolve => {
                linkUrlInput.value = '';
                linkModalBackdrop.classList.remove('hidden');

                const insertHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(linkUrlInput.value);
                };

                const cancelHandler = () => {
                    linkModalBackdrop.classList.add('hidden');
                    resolve(null);
                };

                // Einmalige Event Listener, um Konflikte zu vermeiden
                linkInsertBtn.onclick = insertHandler;
                linkCancelBtn.onclick = cancelHandler;
                
                // Fokus auf das Eingabefeld, sobald das Modal ge√∂ffnet wird
                linkUrlInput.focus();
            });
        };

        // ******************************************************
        // ** SELECTION/FOCUS LOGIK (WICHTIG f√ºr Toolbar) **
        // ******************************************************

        const getSelectionRange = () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                return selection.getRangeAt(0);
            }
            return null;
        };

        const saveSelection = () => {
            savedRange = getSelectionRange();
        };

        const restoreSelection = () => {
            if (savedRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedRange);
                savedRange = null; 
            }
        };

        const collapseSelection = () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                // collapse auf das Ende, um den Cursor zu positionieren
                range.collapse(false); 
                selection.removeAllRanges();
                selection.addRange(range);
            }
        };

        /**
         * F√ºhrt einen Formatierungsbefehl aus und stellt den Fokus in den Editor zur√ºck.
         * @param {string} command - Der execCommand-Befehl.
         * @param {string} value - Der Wert f√ºr den execCommand-Befehl.
         */
        const executeFormatAndRestore = (command, value = null) => {
            // WICHTIG: Auswahl wiederherstellen und Fokus setzen VOR execCommand
            restoreSelection();
            noteEditor.focus(); 

            // F√ºhre den Formatierungsbefehl aus
            document.execCommand(command, false, value);
            // Auswahl/Range erneut speichern, falls sich die Auswahl ge√§ndert hat
            saveSelection();
            // Toolbar-Status aktualisieren
            updateToolbarState();
        };

        const executeLinkCommand = async () => {
            // 1. Auswahl speichern
            saveSelection();
            // 2. Modal anzeigen und auf URL warten
            const url = await showLinkModal();
            // 3. Auswahl wiederherstellen 
            restoreSelection();
            if (url) {
                // F√ºhrt den Link-Befehl aus und ersetzt die aktuelle Auswahl
                document.execCommand('createLink', false, url);
                // Manuelle Korrektur f√ºr target="_blank"
                const selection = window.getSelection();
                const node = selection.anchorNode;
                
                // Versuche, das umgebende A-Tag zu finden
                let linkElement = node.nodeType === Node.TEXT_NODE ?
node.parentNode : node;
                while (linkElement && linkElement !== noteEditor && linkElement.tagName !== 'A') {
                    linkElement = linkElement.parentNode;
                }
                
                if (linkElement && linkElement.tagName === 'A') {
                    linkElement.setAttribute('target', '_blank');
                }
            }
            
            // 4. Fokus in den Editor zur√ºcksetzen
            noteEditor.focus();
            updateToolbarState(); 
        };
        

        // ******************************************************
        // ** AUFZ√ÑHLUNGSLOGIK **
        // ******************************************************

        /**
         * Findet das n√§chste Block-Level-Element (p, div, li, hx)
         * in Bezug auf den aktuellen Cursor innerhalb des noteEditor.
         */
        const getCurrentBlockElement = (selection) => {
            if (!selection.rangeCount) return null;
            let node = selection.getRangeAt(0).startContainer;
            
            // Wenn es ein Textknoten ist, gehe zum √ºbergeordneten Element
            if (node.nodeType === Node.TEXT_NODE) {
                node = node.parentNode;
            }
            
            // Finde den n√§chsten Block-Level-Elternteil (P, DIV, LI)
            while (node && node !== noteEditor) {
                const tagName = node.tagName;
                // F√ºge DIV hinzu, falls der Editor ein leeres DIV erstellt (z.B. bei Enter)
                if (['P', 'DIV', 'LI', 'H1', 'H2', 'H3'].includes(tagName)) {
                    return node;
                }
                node = node.parentNode;
            }
            
            return null;
        };

        /**
         * Wendet eine benutzerdefinierte Listenformatierung (ul/ol mit Stil) an.
         * @param {string} targetStyle - 'decimal', 'disc', 'circle'
         */
        const toggleCustomList = (targetStyle) => {
            restoreSelection(); // Auswahl wiederherstellen
            noteEditor.focus(); // Fokus setzen
            
            const selection = window.getSelection();
            if (!selection || !noteEditor.contains(selection.anchorNode)) return;

            const currentBlock = getCurrentBlockElement(selection);
            
            // Ermittle den aktuellen Listentyp (UL oder OL), falls vorhanden
            const isCurrentlyLi = currentBlock && currentBlock.tagName === 'LI';
            const currentListType = isCurrentlyLi ? currentBlock.parentNode.tagName : null;

            // 1. ANFANG: KEINE LISTE VORHANDEN ODER WIRKLICH EIN NEUES BLOCK-ELEMENT (P/DIV)
            if (!currentBlock || currentBlock.tagName !== 'LI') {
                const command = targetStyle === 'decimal' ? 'insertOrderedList' : 'insertUnorderedList';
                document.execCommand(command);

                // Nach execCommand befindet sich der Cursor wahrscheinlich in einem LI.
                // Wir m√ºssen den Stil sofort anwenden.
                const newBlock = getCurrentBlockElement(selection); 
                if (newBlock && newBlock.tagName === 'LI') {
                    const parentList = newBlock.parentNode;
                    if (parentList.tagName === 'UL') {
                        parentList.style.listStyleType = targetStyle;
                    }
                }
                saveSelection();
                return; // Aktion beendet
            } 
            
            // 2. ZIEL: LISTE AUFHEBEN (LI -> P/DIV)
            if ((targetStyle === 'disc' && currentListType === 'UL' && currentBlock.parentNode.style.listStyleType === 'disc') ||
                (targetStyle === 'circle' && currentListType === 'UL' && currentBlock.parentNode.style.listStyleType === 'circle') ||
                (targetStyle === 'decimal' && currentListType === 'OL')
            ) {
                // F√ºhrt Outdent aus, was die Liste aufl√∂sen kann
                document.execCommand('outdent'); 
                saveSelection();
                return;
            }

            // 3. ZIEL: STIL-WECHSEL INNERHALB UL (disc <-> circle)
            if (isCurrentlyLi && currentListType === 'UL' && targetStyle !== 'decimal') {
                const parentList = currentBlock.parentNode;
                const targetMarkerStyle = targetStyle === 'disc' ? 'disc' : targetStyle; 
                // √Ñndere nur den Stil der Elternliste
                parentList.style.listStyleType = targetMarkerStyle;
                
                // Cursor wiederherstellen
                collapseSelection();
                saveSelection();
                return; // Aktion beendet
            }
            
            // 4. ZIEL: AKTUELL UL ODER OL, ABER ZU ANDERER LISTE WECHSELN (z.B. UL zu OL)
            if (isCurrentlyLi) {
                let command = '';
                if (targetStyle === 'decimal' && currentListType === 'UL') {
                    command = 'insertOrderedList';
                } else if ((targetStyle === 'disc' || targetStyle === 'circle') && currentListType === 'OL') {
                    command = 'insertUnorderedList';
                }

                if (command) {
                    document.execCommand(command);
                    
                    // Wende den Stil nach dem Wechsel an, da der Browser den Standardstil verwendet
                    const newBlock = getCurrentBlockElement(selection);
                    if (newBlock && newBlock.tagName === 'LI') {
                        const parentList = newBlock.parentNode;
                        if (parentList.tagName === 'UL') {
                            parentList.style.listStyleType = targetStyle; // Wende den Stil an
                        }
                    }
                }
            }
            saveSelection();
        };

        // ******************************************************
        // ** FORMATIERUNGSLOGIK **
        // ******************************************************

        const applyFormat = (command, value = null) => {
            noteEditor.focus();
            try {
                document.execCommand(command, false, value);
            } catch (e) {
                // Ignoriere Fehler wie 'applyFormat("foreColor", "white")'
            }
            collapseSelection();
            updateToolbarState(); // Aktualisiert den Status nach der Anwendung
        };

        // ******************************************************
        // ** TOOLBAR AKTUALISIERUNG (ACTIVE MARKER) LOGIK **
        // ******************************************************
        
        const updateToolbarState = () => {
            const selection = window.getSelection();

            // F√úR FOKUS/CURSOR R√úCKKEHR: Speichere die Auswahl bei MouseUp oder KeyUp
            if (document.activeElement === noteEditor) {
                saveSelection();
            }

            if (selection.rangeCount === 0 || !noteEditor.contains(selection.anchorNode)) {
                // Alle Buttons/Dropdowns de-aktivieren, wenn der Fokus nicht im Editor ist
                document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
                
                // Reset Dropdown Button Text
                listDropdownBtn.textContent = 'Aufz√§hlung';
                sizeDropdownBtn.textContent = 'Schriftgr√∂√üe';
                colorDropdownBtn.textContent = 'Schriftfarbe';
                return;
            }

            // Text-Formate (B/I/U/Link)
            boldBtn.classList.toggle('active', document.queryCommandState('bold'));
            italicBtn.classList.toggle('active', document.queryCommandState('italic'));
            underlineBtn.classList.toggle('active', document.queryCommandState('underline'));
            linkBtn.classList.toggle('active', document.queryCommandState('createLink'));

            // 1. Listen-Formate (Dropdown Active Marker FIX)
            listDropdownItems.forEach(item => item.classList.remove('active'));
            const currentBlock = getCurrentBlockElement(selection);
            if (currentBlock) {
                let parentList = currentBlock.closest('UL, OL'); // Finde die Liste, selbst wenn LI ausgew√§hlt ist
                if (parentList) {
                    let activeListStyle = 'disc'; // Default for UL
                    if (parentList.tagName === 'OL') {
                        activeListStyle = parentList.style.listStyleType || 'decimal'; // 'decimal' als Fallback
                    } else if (parentList.tagName === 'UL') {
                        activeListStyle = parentList.style.listStyleType || 'disc';
                    }
                    const activeItem = Array.from(listDropdownItems).find(item => item.dataset.value === activeListStyle);
                    if (activeItem) {
                        activeItem.classList.add('active'); 
                    }
                }
            }
            listDropdownBtn.textContent = 'Aufz√§hlung'; // FIX: Button-Text statisch halten

            // 2. Schriftgr√∂√üe (Dropdown Active Marker FIX)
            sizeDropdownItems.forEach(item => item.classList.remove('active'));
            // queryCommandValue gibt die numerische Gr√∂√üe (1-7) zur√ºck
            let currentSize = document.queryCommandValue('fontSize');
            if (currentSize) {
                const activeItem = Array.from(sizeDropdownItems).find(item => item.dataset.value === currentSize);
                if (activeItem) {
                    activeItem.classList.add('active'); 
                }
            }
            sizeDropdownBtn.textContent = 'Schriftgr√∂√üe'; // FIX: Button-Text statisch halten

            // 3. Schriftfarbe (Dropdown Active Marker FIX)
            colorDropdownItems.forEach(item => item.classList.remove('active'));
            let currentColor = document.queryCommandValue('foreColor');
            if (currentColor) {
                // Farbe in Hex konvertieren, falls RGB
                if (currentColor.startsWith('rgb')) {
                    currentColor = rgbToHex(currentColor);
                }

                // Finde den passenden Key in colorMap
                const colorKey = Object.keys(colorMap).find(key => colorMap[key].toLowerCase() === currentColor.toLowerCase());
                if (colorKey) {
                    const activeItem = Array.from(colorDropdownItems).find(item => item.dataset.value === colorKey);
                    if (activeItem) {
                        activeItem.classList.add('active'); 
                    }
                }
            }
            colorDropdownBtn.textContent = 'Schriftfarbe'; // FIX: Button-Text statisch halten
        };

        // ******************************************************
        // ** STORAGE UND RENDERING LOGIK **
        // ******************************************************
        
        const saveNotesToLocal = () => {
            try {
                // Nur die Reihenfolge in der unsortierten Ansicht speichern
                if (currentSortMethod === 'unsorted') {
                    const unsortedOrder = notesData.map(note => note.id);
                    localStorage.setItem('notes-order', JSON.stringify(unsortedOrder));
                }
                localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notesData));
            } catch (e) {
                console.error("Fehler beim Speichern der Notizen im lokalen Speicher:", e);
                showModal("Ihre Notizen konnten nicht gespeichert werden. Der lokale Speicher ist m√∂glicherweise voll.");
            }
        };

        const loadNotesFromLocal = () => {
            try {
                const storedNotes = localStorage.getItem(NOTES_STORAGE_KEY);
                notesData = storedNotes ? JSON.parse(storedNotes) : [];
                
                // Lade die gespeicherte Reihenfolge f√ºr 'unsorted'
                const storedOrder = localStorage.getItem('notes-order');
                if (storedOrder && storedOrder.length > 0) {
                    const orderArray = JSON.parse(storedOrder);
                    
                    // Sortiere notesData basierend auf der gespeicherten ID-Liste
                    notesData.sort((a, b) => {
                        const indexA = orderArray.indexOf(a.id);
                        const indexB = orderArray.indexOf(b.id);
                        if (indexA === -1 || indexB === -1) {
                            // Neue Notizen ans Ende
                            return a.id - b.id;
                        }
                        return indexA - indexB;
                    });
                } else {
                    // Fallback: Neueste zuerst nach ID (dem urspr√ºnglichen Standard)
                    notesData.sort((a, b) => b.id - a.id);
                }
                
                sortNotes(currentSortMethod, true); // Stellt die Sortierung ein und rendert
            } catch (e) {
                console.error("Fehler beim Laden der Notizen aus dem lokalen Speicher:", e);
                showModal("Ihre Notizen konnten nicht geladen werden.");
            }
        };

        /**
         * Erzeugt eine eindeutige ID (z.B. basierend auf Zeitstempel und Zufall).
         */
        const generateUniqueId = () => {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 7);
        };
        
        /**
         * Bereinigt den HTML-Inhalt des Editors, indem unn√∂tige Attribute entfernt werden.
         * Beh√§lt nur die erlaubten Formatierungen.
         * @param {string} html - Der unbereinigte HTML-String.
         */
        const sanitizeHtml = (html) => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // Erlaubte Tags und Attribute
            const allowedTags = ['b', 'i', 'u', 'a', 'p', 'div', 'ul', 'ol', 'li', 'font'];
            const allowedAttributes = {
                'a': ['href', 'target'],
                'font': ['size', 'color'],
                'ul': ['style'],
                'ol': ['style'],
            };

            const traverse = (node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    
                    // 1. Unerlaubte Tags entfernen (oder durch ihren Inhalt ersetzen)
                    if (!allowedTags.includes(tagName)) {
                        let parent = node.parentNode;
                        while (node.firstChild) {
                            parent.insertBefore(node.firstChild, node);
                        }
                        parent.removeChild(node);
                        return; // Weiter mit dem n√§chsten Geschwisterknoten
                    }

                    // 2. Unerlaubte Attribute entfernen
                    const attributesToRemove = [];
                    for (let i = 0; i < node.attributes.length; i++) {
                        const attr = node.attributes[i];
                        const allowedForTag = allowedAttributes[tagName] || [];
                        if (!allowedForTag.includes(attr.name)) {
                            attributesToRemove.push(attr.name);
                        }
                    }
                    attributesToRemove.forEach(name => node.removeAttribute(name));
                    
                    // 3. Rekursive Verarbeitung der Kinder
                    let child = node.firstChild;
                    while (child) {
                        const nextChild = child.nextSibling;
                        traverse(child);
                        child = nextChild;
                    }
                } else if (node.nodeType === Node.TEXT_NODE) {
                    // Textknoten behalten
                } else {
                    // Alle anderen Knotentypen (Kommentare, etc.) entfernen
                    node.parentNode.removeChild(node);
                }
            };

            traverse(tempDiv);
            
            // Spezialbehandlung: Wenn nur <br> √ºbrig bleiben, ersetze durch leeren String
            let cleanedHtml = tempDiv.innerHTML.trim();
            if (cleanedHtml === '<br>') return '';

            return cleanedHtml;
        };

        const saveNote = () => {
            // Aktuelle Auswahl verwerfen, damit der Fokus im Editor bleibt, falls er dort war
            if (document.activeElement === noteEditor) {
                noteEditor.blur();
            }

            const title = noteTitleInput.value.trim();
            const content = sanitizeHtml(noteEditor.innerHTML);

            if (!title && !content) {
                showModal("Die Notiz ist leer. Bitte geben Sie einen Titel oder Inhalt ein.");
                return;
            }

            if (editingNoteId) {
                // Notiz bearbeiten (Edit-Modus)
                const index = notesData.findIndex(note => note.id === editingNoteId);
                if (index !== -1) {
                    notesData[index].title = title;
                    notesData[index].content = content;
                    notesData[index].updatedAt = Date.now();
                }
                editingNoteId = null;
            } else {
                // Neue Notiz erstellen
                const newNote = {
                    id: generateUniqueId(),
                    title: title,
                    content: content,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    color: 'default' // Kann sp√§ter erweitert werden
                };
                notesData.push(newNote);
                
                // Bei einer neuen Notiz muss die ungerendert-Reihenfolge aktualisiert werden
                if (currentSortMethod === 'unsorted') {
                    // F√ºgen Sie die neue ID am Ende der gespeicherten Reihenfolge hinzu (oder passen Sie es an, wenn Sie m√∂chten, dass neue Notizen oben erscheinen)
                    const currentOrderStr = localStorage.getItem('notes-order');
                    let currentOrder = currentOrderStr ? JSON.parse(currentOrderStr) : notesData.map(n => n.id);
                    currentOrder.push(newNote.id);
                    localStorage.setItem('notes-order', JSON.stringify(currentOrder));
                }
            }

            // Felder zur√ºcksetzen
            noteTitleInput.value = '';
            noteEditor.innerHTML = '';
            
            // Toolbar-Buttons zur√ºcksetzen
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));

            saveNotesToLocal();
            // Notizen neu rendern (mit Suchfilter, falls aktiv)
            renderNotes(searchInput.value);
            showModal(editingNoteId ? "Notiz erfolgreich aktualisiert!" : "Neue Notiz erfolgreich gespeichert!");
        };

        const editNote = (id, title, content) => {
            noteTitleInput.value = title;
            noteEditor.innerHTML = content;
            editingNoteId = id;
            noteEditor.focus();
            
            // Scrolle zum Notiz-Erstellungsbereich
            document.querySelector('.bg-gray-900').scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Toolbar-Status aktualisieren, da sich der Fokus ge√§ndert hat
            updateToolbarState();
        };

        const deleteNote = (id) => {
            showModal("Sind Sie sicher, dass Sie diese Notiz l√∂schen m√∂chten? Dieser Vorgang kann nicht r√ºckg√§ngig gemacht werden.", true)
                .then(confirmed => {
                    if (confirmed) {
                        notesData = notesData.filter(note => note.id !== id);
                        saveNotesToLocal();
                        renderNotes(searchInput.value);
                        
                        // Wenn die gerade bearbeitete Notiz gel√∂scht wurde
                        if (editingNoteId === id) {
                            editingNoteId = null;
                            noteTitleInput.value = '';
                            noteEditor.innerHTML = '';
                        }
                        
                        showModal("Notiz erfolgreich gel√∂scht.");
                    }
                });
        };
        
        // ******************************************************
        // ** SORTIERLOGIK **
        // ******************************************************
        const sortNotes = (method, silent = false) => {
            currentSortMethod = method;
            let sortedNotes = [...notesData];

            switch (method) {
                case 'newest':
                    sortedNotes.sort((a, b) => b.createdAt - a.createdAt);
                    sortDropdownBtn.textContent = 'Sortieren nach: Neueste';
                    break;
                case 'oldest':
                    sortedNotes.sort((a, b) => a.createdAt - b.createdAt);
                    sortDropdownBtn.textContent = 'Sortieren nach: √Ñlteste';
                    break;
                case 'title-asc':
                    sortedNotes.sort((a, b) => a.title.localeCompare(b.title));
                    sortDropdownBtn.textContent = 'Sortieren nach: Titel (A-Z)';
                    break;
                case 'title-desc':
                    sortedNotes.sort((a, b) => b.title.localeCompare(a.title));
                    sortDropdownBtn.textContent = 'Sortieren nach: Titel (Z-A)';
                    break;
                case 'unsorted':
                default:
                    // Wenn 'unsorted', laden wir die Reihenfolge aus dem Speicher neu.
                    loadNotesFromLocal(); 
                    sortDropdownBtn.textContent = 'Sortieren nach: Unsortiert';
                    // Der Render-Prozess muss hier abgebrochen und von loadNotesFromLocal √ºbernommen werden, 
                    // um die Reihenfolge aus dem Speicher zu verwenden.
                    return; 
            }
            
            // Setze den Active-Status im Dropdown
            sortDropdownItems.forEach(item => {
                item.classList.remove('active');
                if (item.dataset.value === method) {
                    item.classList.add('active');
                }
            });

            // Ersetze die Haupt-Daten mit den sortierten Daten, WENN es nicht die unsortierte Ansicht ist
            if (method !== 'unsorted') {
                notesData = sortedNotes;
            }

            if (!silent) {
                 renderNotes(searchInput.value); // Notizen rendern
            }
        };


        const renderNotes = (searchTerm = '') => {
            const currentNotesToDisplay = notesData.filter(note => {
                const searchLower = searchTerm.toLowerCase();
                const titleLower = note.title.toLowerCase();
                const contentLower = note.content.toLowerCase();
                
                return titleLower.includes(searchLower) || contentLower.includes(searchLower);
            });

            notesList.innerHTML = ''; // Liste leeren
            
            loadingIndicator.classList.add('hidden');
            
            if (currentNotesToDisplay.length === 0) {
                noNotesMessage.classList.remove('hidden');
                if (notesData.length > 0) {
                     noNotesMessage.querySelector('p').textContent = `Keine Notizen gefunden f√ºr "${searchTerm}".`;
                } else {
                     noNotesMessage.querySelector('p').textContent = `Sie haben noch keine Notizen. F√ºgen Sie eine neue hinzu, um zu beginnen!`;
                }
            } else {
                noNotesMessage.classList.add('hidden');
            }

            currentNotesToDisplay.forEach(note => {
                const noteElement = createNoteCard(note);
                notesList.appendChild(noteElement);
            });
            
            // Drag-Funktionalit√§t basierend auf dem Sortiermodus aktivieren/deaktivieren
            document.querySelectorAll('.note-card').forEach(card => {
                card.draggable = (currentSortMethod === 'unsorted');
            });
        };

        const createNoteCard = (note) => {
             const div = document.createElement('div');
             div.className = 'note-card p-4 rounded-xl shadow-lg border';
             div.id = `note-${note.id}`;
             div.dataset.id = note.id;
             div.draggable = (currentSortMethod === 'unsorted');
             
             // Titel nur anzeigen, wenn er vorhanden ist
             const titleHtml = note.title.trim() ? 
                `<h3 class="text-xl font-semibold text-gray-100 mr-4">${note.title}</h3>` : 
                '';

             div.innerHTML = `
                 <div class="flex justify-between items-start mb-2">
                     ${titleHtml}
                     <div class="flex space-x-2 ml-auto">
                        <button class="edit-btn calculator-btn note-action-btn text-gray-200">
                            ‚úèÔ∏è
                        </button>
                        <button class="delete-btn calculator-btn note-action-btn text-gray-200">
                            üóëÔ∏è
                        </button>
                    </div>
                 </div>
                 <div class="text-gray-300 mb-4" style="font-size: 1rem;">${note.content}</div>
             `;
             
             div.querySelector('.edit-btn').addEventListener('click', () => editNote(note.id, note.title, note.content));
             div.querySelector('.delete-btn').addEventListener('click', () => deleteNote(note.id));
             
             // Nur Drag-Listener hinzuf√ºgen, wenn Drag erlaubt ist
             if (currentSortMethod === 'unsorted') {
                 div.addEventListener('dragstart', handleDragStart);
                 div.addEventListener('dragover', handleDragOver);
                 div.addEventListener('drop', handleDrop);
                 div.addEventListener('dragend', handleDragEnd);
             }
             return div;
        };
        
        // ******************************************************
        // ** DRAG & DROP LOGIK **
        // ******************************************************

        const handleDragStart = (e) => {
            if (currentSortMethod !== 'unsorted') {
                e.preventDefault();
                return;
            }
            draggedItem = e.target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML);
            // Verz√∂gerung, um die Klasse nach dem Datentransfer hinzuzuf√ºgen
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        };

        const handleDragOver = (e) => {
            if (currentSortMethod !== 'unsorted') {
                e.preventDefault();
                return;
            }
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.target.closest('.note-card');
            if (target && target !== draggedItem) {
                // Finde den Mittelpunkt des Ziels
                const rect = target.getBoundingClientRect();
                const centerY = rect.top + rect.height / 2;
                
                // F√ºge das gezogene Element entweder davor oder danach ein
                const isBefore = e.clientY < centerY;
                const notesList = document.getElementById('notes-list');

                if (isBefore) {
                    // Vor dem Ziel einf√ºgen, wenn es das vorherige Element ist,
                    // sonst sollte es nach dem vorherigen eingef√ºgt werden.
                    notesList.insertBefore(draggedItem, target);
                } else {
                    // Nach dem Ziel einf√ºgen
                    notesList.insertBefore(draggedItem, target.nextSibling);
                }
            }
        };

        const handleDrop = (e) => {
            if (currentSortMethod !== 'unsorted') {
                e.preventDefault();
                return;
            }
            e.preventDefault();
            
            const target = e.target.closest('.note-card');
            if (target && target !== draggedItem) {
                // Die Reihenfolge im DOM ist bereits im handleDragOver aktualisiert.
                // Jetzt m√ºssen wir die Reihenfolge in notesData aktualisieren.
                
                // 1. Die neue Reihenfolge der IDs aus dem DOM abrufen
                const newOrder = Array.from(notesList.children)
                                      .map(child => child.dataset.id)
                                      .filter(id => id); // Filtert Nicht-Notiz-Elemente
                
                // 2. Die notesData entsprechend der neuen Reihenfolge neu anordnen
                const newNotesData = [];
                newOrder.forEach(id => {
                    const note = notesData.find(n => n.id === id);
                    if (note) {
                        newNotesData.push(note);
                    }
                });
                
                // 3. Neue Daten speichern
                notesData = newNotesData;
                saveNotesToLocal();
            }
        };

        const handleDragEnd = (e) => {
            if (currentSortMethod !== 'unsorted') {
                e.preventDefault();
                return;
            }
            // Entferne die dragging-Klasse immer
            draggedItem.classList.remove('dragging');
            draggedItem = null;
        };

        // ******************************************************
        // ** IMPORT/EXPORT LOGIK **
        // ******************************************************
        
        const exportNotes = () => {
            if (notesData.length === 0) {
                showModal("Es gibt keine Notizen zum Exportieren.");
                return;
            }
            
            const dataStr = JSON.stringify(notesData, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `offline-notizen-export-${new Date().toISOString().split('T')[0]}.json`;
            
            // F√ºhre den Klick aus und entferne das Element
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showModal("Notizen wurden erfolgreich als JSON-Datei exportiert.");
        };

        const importNotes = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedNotes = JSON.parse(e.target.result);
                    
                    if (!Array.isArray(importedNotes) || importedNotes.some(n => !n.id || !n.content)) {
                        showModal("Ung√ºltiges Dateiformat. Die Datei muss ein Array von Notizobjekten enthalten.");
                        return;
                    }
                    
                    showModal(`Es wurden ${importedNotes.length} Notizen in der Datei gefunden. M√∂chten Sie diese importieren? (Vorhandene Notizen werden NICHT √ºberschrieben.)`, true)
                        .then(confirmed => {
                            if (confirmed) {
                                // Filtere doppelte IDs (falls vorhanden) und f√ºge neue Notizen hinzu
                                const existingIds = new Set(notesData.map(n => n.id));
                                const newNotes = importedNotes.filter(n => !existingIds.has(n.id));
                                
                                notesData = [...notesData, ...newNotes];
                                
                                // Setze die Import-Reihenfolge auf das Ende der unsortierten Liste
                                const importedIds = newNotes.map(note => note.id);
                                const currentOrderStr = localStorage.getItem('notes-order');
                                let currentOrder = currentOrderStr ? JSON.parse(currentOrderStr) : notesData.map(n => n.id);
                                currentOrder = [...currentOrder.filter(id => !importedIds.includes(id)), ...importedIds];
                                localStorage.setItem('notes-order', JSON.stringify(currentOrder));

                                saveNotesToLocal();
                                renderNotes(searchInput.value);
                                
                                showModal(`Import abgeschlossen! ${newNotes.length} neue Notizen wurden hinzugef√ºgt.`);
                            }
                        });
                    
                } catch (error) {
                    showModal("Fehler beim Lesen oder Parsen der Datei. Stellen Sie sicher, dass es eine g√ºltige JSON-Datei ist.");
                    console.error("Import error:", error);
                }
            };

            reader.readAsText(file);
            event.target.value = ''; // Setze das File-Input zur√ºck, damit das gleiche File erneut importiert werden kann
        };
        
        // ******************************************************
        // ** EVENT LISTENER **
        // ******************************************************

        // Toolbar-Befehle
        boldBtn.addEventListener('click', () => executeFormatAndRestore('bold'));
        italicBtn.addEventListener('click', () => executeFormatAndRestore('italic'));
        underlineBtn.addEventListener('click', () => executeFormatAndRestore('underline'));
        indentBtn.addEventListener('click', () => executeFormatAndRestore('indent'));
        outdentBtn.addEventListener('click', () => executeFormatAndRestore('outdent'));
        linkBtn.addEventListener('click', executeLinkCommand);

        // Dropdown-Toggle (mit event.stopPropagation, um Klick-Bug zu vermeiden)
        const toggleDropdown = (btn, menu) => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Alle anderen Dropdowns schlie√üen
                document.querySelectorAll('.dropdown-menu').forEach(m => {
                    if (m !== menu) {
                        m.classList.remove('active');
                    }
                });
                
                menu.classList.toggle('active');
                updateToolbarState(); // Wichtig, um den aktuellen Zustand der Toolbar zu erfassen
            });
        };
        
        toggleDropdown(listDropdownBtn, listDropdownMenu);
        toggleDropdown(sizeDropdownBtn, sizeDropdownMenu);
        toggleDropdown(colorDropdownBtn, colorDropdownMenu);
        toggleDropdown(sortDropdownBtn, sortDropdownMenu);


        // Dropdown-Befehle ausf√ºhren (mit neuer Listen-Logik)
        listDropdownItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation(); 
                e.currentTarget.blur();
                
                // RUFE LIST-LOGIK AUF
                toggleCustomList(item.dataset.value); 

                // Editor Focus im Timeout
                setTimeout(() => {
                    noteEditor.focus();
                    updateToolbarState();
                }, 1);
                listDropdownMenu.classList.remove('active'); 
            });
        });
        sizeDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            executeFormatAndRestore('fontSize', item.dataset.value);
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
        }));
        colorDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            // document.execCommand erwartet den Farbnamen oder Hex/RGB-Code
            executeFormatAndRestore('foreColor', colorMap[item.dataset.value]); 
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
        }));
        sortDropdownItems.forEach(item => item.addEventListener('click', (e) => {
            e.stopPropagation();
            sortNotes(item.dataset.value);
            sortDropdownMenu.classList.remove('active');
        }));

        // Globale Klick-Events zum Schlie√üen von Dropdowns
        document.addEventListener('click', () => {
            listDropdownMenu.classList.remove('active');
            sizeDropdownMenu.classList.remove('active');
            colorDropdownMenu.classList.remove('active');
            sortDropdownMenu.classList.remove('active');
        });
        
        // Speichern und Suchen
        saveNoteBtn.addEventListener('click', saveNote);
        searchInput.addEventListener('input', (e) => renderNotes(e.target.value));
        
        // Import/Export
        exportBtn.addEventListener('click', exportNotes);
        importFileInput.addEventListener('change', importNotes);
        
        // Event listener zur Aktualisierung des Toolbar-Zustands bei Fokuswechsel/Eingabe
        noteEditor.addEventListener('mouseup', saveSelection); // Speichern der Auswahl bei Mausklick
        noteEditor.addEventListener('keyup', saveSelection); // Speichern der Auswahl bei Tastendruck
        noteEditor.addEventListener('input', updateToolbarState);
        noteEditor.addEventListener('focus', updateToolbarState);
        noteEditor.addEventListener('blur', updateToolbarState);


        // Initial loading of notes
        window.addEventListener('load', loadNotesFromLocal);
    </script>
</body>
</html>
